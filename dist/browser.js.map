{
  "version": 3,
  "sources": ["../node_modules/@maskito/core/index.esm.js", "../node_modules/@maskito/kit/index.esm.js", "../src/browser.ts"],
  "sourcesContent": ["function getContentEditableSelection(element) {\n    const { anchorOffset = 0, focusOffset = 0 } = element.ownerDocument.getSelection() || {};\n    const from = Math.min(anchorOffset, focusOffset);\n    const to = Math.max(anchorOffset, focusOffset);\n    return [from, to];\n}\n\nfunction setContentEditableSelection(element, [from, to]) {\n    var _a, _b, _c, _d;\n    const document = element.ownerDocument;\n    const range = document.createRange();\n    range.setStart(element.firstChild || element, Math.min(from, (_b = (_a = element.textContent) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0));\n    range.setEnd(element.lastChild || element, Math.min(to, (_d = (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0));\n    const selection = document.getSelection();\n    if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n\nclass ContentEditableAdapter {\n    constructor(element) {\n        this.element = element;\n        this.maxLength = Infinity;\n    }\n    get value() {\n        return this.element.innerText.replace(/\\n\\n$/, '\\n');\n    }\n    set value(value) {\n        // Setting into innerHTML of element with `white-space: pre;` style\n        this.element.innerHTML = value.replace(/\\n$/, '\\n\\n');\n    }\n    get selectionStart() {\n        return getContentEditableSelection(this.element)[0];\n    }\n    get selectionEnd() {\n        return getContentEditableSelection(this.element)[1];\n    }\n    setSelectionRange(from, to) {\n        setContentEditableSelection(this.element, [from !== null && from !== void 0 ? from : 0, to !== null && to !== void 0 ? to : 0]);\n    }\n    select() {\n        this.setSelectionRange(0, this.value.length);\n    }\n}\nfunction maskitoAdaptContentEditable(element) {\n    const adapter = new ContentEditableAdapter(element);\n    return new Proxy(element, {\n        get(target, prop) {\n            if (prop in adapter) {\n                return adapter[prop];\n            }\n            const nativeProperty = target[prop];\n            return typeof nativeProperty === 'function'\n                ? nativeProperty.bind(target)\n                : nativeProperty;\n        },\n        // eslint-disable-next-line @typescript-eslint/max-params\n        set(target, prop, val, receiver) {\n            return Reflect.set(prop in adapter ? adapter : target, prop, val, receiver);\n        },\n    });\n}\n\nconst MASKITO_DEFAULT_ELEMENT_PREDICATE = (e) => e.isContentEditable\n    ? maskitoAdaptContentEditable(e)\n    : e.querySelector('input,textarea') ||\n        e;\n\nconst MASKITO_DEFAULT_OPTIONS = {\n    mask: /^.*$/,\n    preprocessors: [],\n    postprocessors: [],\n    plugins: [],\n    overwriteMode: 'shift',\n};\n\nclass MaskHistory {\n    constructor() {\n        this.now = null;\n        this.past = [];\n        this.future = [];\n    }\n    undo() {\n        const state = this.past.pop();\n        if (state && this.now) {\n            this.future.push(this.now);\n            this.updateElement(state, 'historyUndo');\n        }\n    }\n    redo() {\n        const state = this.future.pop();\n        if (state && this.now) {\n            this.past.push(this.now);\n            this.updateElement(state, 'historyRedo');\n        }\n    }\n    updateHistory(state) {\n        if (!this.now) {\n            this.now = state;\n            return;\n        }\n        const isValueChanged = this.now.value !== state.value;\n        const isSelectionChanged = this.now.selection.some((item, index) => item !== state.selection[index]);\n        if (!isValueChanged && !isSelectionChanged) {\n            return;\n        }\n        if (isValueChanged) {\n            this.past.push(this.now);\n            this.future = [];\n        }\n        this.now = state;\n    }\n    updateElement(state, inputType) {\n        this.now = state;\n        this.updateElementState(state, { inputType, data: null });\n    }\n}\n\nfunction areElementValuesEqual(sampleState, ...states) {\n    return states.every(({ value }) => value === sampleState.value);\n}\nfunction areElementStatesEqual(sampleState, ...states) {\n    return states.every(({ value, selection }) => value === sampleState.value &&\n        selection[0] === sampleState.selection[0] &&\n        selection[1] === sampleState.selection[1]);\n}\n\nfunction applyOverwriteMode({ value, selection }, newCharacters, mode) {\n    const [from, to] = selection;\n    const computedMode = typeof mode === 'function' ? mode({ value, selection }) : mode;\n    return {\n        value,\n        selection: computedMode === 'replace'\n            ? [from, Math.max(from + newCharacters.length, to)]\n            : [from, to],\n    };\n}\n\nfunction isFixedCharacter(char) {\n    return typeof char === 'string';\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction getLeadingFixedCharacters(mask, validatedValuePart, newCharacter, initialElementState) {\n    let leadingFixedCharacters = '';\n    for (let i = validatedValuePart.length; i < mask.length; i++) {\n        const charConstraint = mask[i] || '';\n        const isInitiallyExisted = (initialElementState === null || initialElementState === void 0 ? void 0 : initialElementState.value[i]) === charConstraint;\n        if (!isFixedCharacter(charConstraint) ||\n            (charConstraint === newCharacter && !isInitiallyExisted)) {\n            return leadingFixedCharacters;\n        }\n        leadingFixedCharacters += charConstraint;\n    }\n    return leadingFixedCharacters;\n}\n\nfunction validateValueWithMask(value, maskExpression) {\n    if (Array.isArray(maskExpression)) {\n        return (value.length === maskExpression.length &&\n            Array.from(value).every((char, i) => {\n                const charConstraint = maskExpression[i] || '';\n                return isFixedCharacter(charConstraint)\n                    ? char === charConstraint\n                    : char.match(charConstraint);\n            }));\n    }\n    return maskExpression.test(value);\n}\n\nfunction guessValidValueByPattern(elementState, mask, initialElementState) {\n    let maskedFrom = null;\n    let maskedTo = null;\n    const maskedValue = Array.from(elementState.value).reduce((validatedCharacters, char, charIndex) => {\n        const leadingCharacters = getLeadingFixedCharacters(mask, validatedCharacters, char, initialElementState);\n        const newValidatedChars = validatedCharacters + leadingCharacters;\n        const charConstraint = mask[newValidatedChars.length] || '';\n        if (maskedFrom === null && charIndex >= elementState.selection[0]) {\n            maskedFrom = newValidatedChars.length;\n        }\n        if (maskedTo === null && charIndex >= elementState.selection[1]) {\n            maskedTo = newValidatedChars.length;\n        }\n        if (isFixedCharacter(charConstraint)) {\n            return newValidatedChars + charConstraint;\n        }\n        if (char.match(charConstraint)) {\n            return newValidatedChars + char;\n        }\n        return leadingCharacters.startsWith(char)\n            ? newValidatedChars\n            : validatedCharacters;\n    }, '');\n    const trailingFixedCharacters = getLeadingFixedCharacters(mask, maskedValue, '', initialElementState);\n    return {\n        value: validateValueWithMask(maskedValue + trailingFixedCharacters, mask)\n            ? maskedValue + trailingFixedCharacters\n            : maskedValue,\n        selection: [maskedFrom !== null && maskedFrom !== void 0 ? maskedFrom : maskedValue.length, maskedTo !== null && maskedTo !== void 0 ? maskedTo : maskedValue.length],\n    };\n}\n\nfunction guessValidValueByRegExp({ value, selection }, maskRegExp) {\n    const [from, to] = selection;\n    let newFrom = from;\n    let newTo = to;\n    const validatedValue = Array.from(value).reduce((validatedValuePart, char, i) => {\n        const newPossibleValue = validatedValuePart + char;\n        if (from === i) {\n            newFrom = validatedValuePart.length;\n        }\n        if (to === i) {\n            newTo = validatedValuePart.length;\n        }\n        return newPossibleValue.match(maskRegExp) ? newPossibleValue : validatedValuePart;\n    }, '');\n    return {\n        value: validatedValue,\n        selection: [\n            Math.min(newFrom, validatedValue.length),\n            Math.min(newTo, validatedValue.length),\n        ],\n    };\n}\n\nfunction calibrateValueByMask(elementState, mask, initialElementState = null) {\n    if (validateValueWithMask(elementState.value, mask)) {\n        return elementState;\n    }\n    const { value, selection } = Array.isArray(mask)\n        ? guessValidValueByPattern(elementState, mask, initialElementState)\n        : guessValidValueByRegExp(elementState, mask);\n    return {\n        selection,\n        value: Array.isArray(mask) ? value.slice(0, mask.length) : value,\n    };\n}\n\nfunction removeFixedMaskCharacters(initialElementState, mask) {\n    if (!Array.isArray(mask)) {\n        return initialElementState;\n    }\n    const [from, to] = initialElementState.selection;\n    const selection = [];\n    const unmaskedValue = Array.from(initialElementState.value).reduce((rawValue, char, i) => {\n        const charConstraint = mask[i] || '';\n        if (i === from) {\n            selection.push(rawValue.length);\n        }\n        if (i === to) {\n            selection.push(rawValue.length);\n        }\n        return isFixedCharacter(charConstraint) && charConstraint === char\n            ? rawValue\n            : rawValue + char;\n    }, '');\n    if (selection.length < 2) {\n        selection.push(...new Array(2 - selection.length).fill(unmaskedValue.length));\n    }\n    return {\n        value: unmaskedValue,\n        selection: [selection[0], selection[1]],\n    };\n}\n\nclass MaskModel {\n    constructor(initialElementState, maskOptions) {\n        this.maskOptions = maskOptions;\n        this.unmaskInitialState = { value: '', selection: [0, 0] };\n        this.value = '';\n        this.selection = [0, 0];\n        const expression = this.getMaskExpression(initialElementState);\n        const { value, selection } = calibrateValueByMask(initialElementState, expression);\n        this.unmaskInitialState = removeFixedMaskCharacters({ value, selection }, expression);\n        this.value = value;\n        this.selection = selection;\n    }\n    addCharacters(newCharacters) {\n        const { value, selection, maskOptions } = this;\n        const initialElementState = { value, selection };\n        const { selection: [from, to], } = applyOverwriteMode(initialElementState, newCharacters, maskOptions.overwriteMode);\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + newCharacters + value.slice(to),\n            selection: [from + newCharacters.length, from + newCharacters.length],\n        });\n        const [unmaskedFrom, unmaskedTo] = applyOverwriteMode(this.unmaskInitialState, newCharacters, maskOptions.overwriteMode).selection;\n        const newUnmaskedLeadingValuePart = this.unmaskInitialState.value.slice(0, unmaskedFrom) + newCharacters;\n        const newCaretIndex = newUnmaskedLeadingValuePart.length;\n        const maskedElementState = calibrateValueByMask({\n            value: newUnmaskedLeadingValuePart +\n                this.unmaskInitialState.value.slice(unmaskedTo),\n            selection: [newCaretIndex, newCaretIndex],\n        }, maskExpression, initialElementState);\n        const prevLeadingPart = value.slice(0, from);\n        const newLeadingPartState = calibrateValueByMask({\n            value: newUnmaskedLeadingValuePart,\n            selection: [newCaretIndex, newCaretIndex],\n        }, maskExpression, initialElementState);\n        const isInvalidCharsInsertion = newLeadingPartState.value === prevLeadingPart ||\n            (newLeadingPartState.value.length < prevLeadingPart.length &&\n                removeFixedMaskCharacters(newLeadingPartState, maskExpression).value ===\n                    this.unmaskInitialState.value.slice(0, unmaskedFrom));\n        if (isInvalidCharsInsertion ||\n            areElementStatesEqual(this, maskedElementState) // If typing new characters does not change value\n        ) {\n            throw new Error('Invalid mask value');\n        }\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    deleteCharacters() {\n        const [from, to] = this.selection;\n        if (from === to || !to) {\n            return;\n        }\n        const { value } = this;\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + value.slice(to),\n            selection: [from, from],\n        });\n        const initialElementState = { value};\n        const [unmaskedFrom, unmaskedTo] = this.unmaskInitialState.selection;\n        const newUnmaskedValue = this.unmaskInitialState.value.slice(0, unmaskedFrom) +\n            this.unmaskInitialState.value.slice(unmaskedTo);\n        const maskedElementState = calibrateValueByMask({ value: newUnmaskedValue, selection: [unmaskedFrom, unmaskedFrom] }, maskExpression, initialElementState);\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    getMaskExpression(elementState) {\n        const { mask } = this.maskOptions;\n        return typeof mask === 'function' ? mask(elementState) : mask;\n    }\n}\n\nclass EventListener {\n    constructor(element) {\n        this.element = element;\n        this.listeners = [];\n    }\n    listen(eventType, fn, options) {\n        const untypedFn = fn;\n        this.element.addEventListener(eventType, untypedFn, options);\n        this.listeners.push(() => this.element.removeEventListener(eventType, untypedFn, options));\n    }\n    destroy() {\n        this.listeners.forEach((stopListen) => stopListen());\n    }\n}\n\nconst HotkeyModifier = {\n    CTRL: 1 << 0,\n    ALT: 1 << 1,\n    SHIFT: 1 << 2,\n    META: 1 << 3,\n};\n// TODO add variants that can be processed correctly\nconst HotkeyCode = {\n    Y: 89,\n    Z: 90,\n};\n/**\n * Checks if the passed keyboard event match the required hotkey.\n *\n * @example\n * input.addEventListener('keydown', (event) => {\n *     if (isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z)) {\n *         // redo hotkey pressed\n *     }\n * })\n *\n * @return will return `true` only if the {@link HotkeyCode} matches and only the necessary\n * {@link HotkeyModifier modifiers} have been pressed\n */\nfunction isHotkey(event, modifiers, hotkeyCode) {\n    return (event.ctrlKey === !!(modifiers & HotkeyModifier.CTRL) &&\n        event.altKey === !!(modifiers & HotkeyModifier.ALT) &&\n        event.shiftKey === !!(modifiers & HotkeyModifier.SHIFT) &&\n        event.metaKey === !!(modifiers & HotkeyModifier.META) &&\n        /**\n         * We intentionally use legacy {@link KeyboardEvent#keyCode `keyCode`} property. It is more\n         * \"keyboard-layout\"-independent than {@link KeyboardEvent#key `key`} or {@link KeyboardEvent#code `code`} properties.\n         * @see {@link https://github.com/taiga-family/maskito/issues/315 `KeyboardEvent#code` issue}\n         */\n        event.keyCode === hotkeyCode);\n}\n\nfunction isRedo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Y) || // Windows\n        isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META | HotkeyModifier.SHIFT, HotkeyCode.Z) // macOS & iOS\n    );\n}\nfunction isUndo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META, HotkeyCode.Z) // macOS & iOS\n    );\n}\n\n/**\n * Sets value to element, and dispatches input event\n * if you passed ELementState, it also sets selection range\n *\n * @example\n * maskitoUpdateElement(input, newValue);\n * maskitoUpdateElement(input, elementState);\n *\n * @see {@link https://github.com/taiga-family/maskito/issues/804 issue}\n *\n * @return void\n */\nfunction maskitoUpdateElement(element, valueOrElementState) {\n    var _a;\n    const initialValue = element.value;\n    if (typeof valueOrElementState === 'string') {\n        element.value = valueOrElementState;\n    }\n    else {\n        const [from, to] = valueOrElementState.selection;\n        element.value = valueOrElementState.value;\n        if (element.matches(':focus')) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    if (element.value !== initialValue) {\n        element.dispatchEvent(new Event('input', \n        /**\n         * React handles this event only on bubbling phase\n         *\n         * here is the list of events that are processed in the capture stage, others are processed in the bubbling stage\n         * https://github.com/facebook/react/blob/cb2439624f43c510007f65aea5c50a8bb97917e4/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js#L222\n         */\n        { bubbles: true }));\n    }\n}\n\nfunction getLineSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const nearestBreak = isForward\n        ? value.slice(from).indexOf('\\n') + 1 || value.length\n        : value.slice(0, to).lastIndexOf('\\n') + 1;\n    const selectFrom = isForward ? from : nearestBreak;\n    const selectTo = isForward ? nearestBreak : to;\n    return [selectFrom, selectTo];\n}\n\nfunction getNotEmptySelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const notEmptySelection = isForward ? [from, to + 1] : [from - 1, to];\n    return notEmptySelection.map((x) => Math.min(Math.max(x, 0), value.length));\n}\n\nconst TRAILING_SPACES_REG = /\\s+$/g;\nconst LEADING_SPACES_REG = /^\\s+/g;\nconst SPACE_REG = /\\s/;\nfunction getWordSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    if (isForward) {\n        const valueAfterSelectionStart = value.slice(from);\n        const [leadingSpaces] = valueAfterSelectionStart.match(LEADING_SPACES_REG) || [\n            '',\n        ];\n        const nearestWordEndIndex = valueAfterSelectionStart\n            .trimStart()\n            .search(SPACE_REG);\n        return [\n            from,\n            nearestWordEndIndex !== -1\n                ? from + leadingSpaces.length + nearestWordEndIndex\n                : value.length,\n        ];\n    }\n    const valueBeforeSelectionEnd = value.slice(0, to);\n    const [trailingSpaces] = valueBeforeSelectionEnd.match(TRAILING_SPACES_REG) || [''];\n    const selectedWordLength = valueBeforeSelectionEnd\n        .trimEnd()\n        .split('')\n        .reverse()\n        .findIndex((char) => SPACE_REG.exec(char));\n    return [\n        selectedWordLength !== -1 ? to - trailingSpaces.length - selectedWordLength : 0,\n        to,\n    ];\n}\n\n/* eslint-disable @typescript-eslint/no-restricted-types */\n/**\n * @internal\n */\nfunction maskitoPipe(processors = []) {\n    return (initialData, ...readonlyArgs) => processors.reduce((data, fn) => (Object.assign(Object.assign({}, data), fn(data, ...readonlyArgs))), initialData);\n}\n\nfunction maskitoTransform(valueOrState, maskitoOptions) {\n    const options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), maskitoOptions);\n    const preprocessor = maskitoPipe(options.preprocessors);\n    const postprocessor = maskitoPipe(options.postprocessors);\n    const initialElementState = typeof valueOrState === 'string'\n        ? { value: valueOrState, selection: [0, 0] }\n        : valueOrState;\n    const { elementState } = preprocessor({ elementState: initialElementState, data: '' }, 'validation');\n    const maskModel = new MaskModel(elementState, options);\n    const { value, selection } = postprocessor(maskModel, initialElementState);\n    return typeof valueOrState === 'string' ? value : { value, selection };\n}\n\n/**\n * All `input` events with `inputType=deleteContentBackward` always follows `beforeinput` event with the same `inputType`.\n * If `beforeinput[inputType=deleteContentBackward]` is prevented, subsequent `input[inputType=deleteContentBackward]` is prevented too.\n * There is an exception \u2013 Android devices with Microsoft SwiftKey Keyboard in Mobile Chrome.\n * These devices ignores `preventDefault` for `beforeinput` event if Backspace is pressed.\n * @see https://github.com/taiga-family/maskito/issues/2135#issuecomment-2980729647\n * ___\n * TODO: track Chromium bug report and delete this plugin after bug fix\n * https://issues.chromium.org/issues/40885402\n */\nfunction createBrokenDefaultPlugin() {\n    return (element) => {\n        const eventListener = new EventListener(element);\n        let isVirtualAndroidKeyboard = false;\n        let beforeinputEvent;\n        let value = element.value;\n        eventListener.listen('keydown', ({ key }) => {\n            isVirtualAndroidKeyboard = key === 'Unidentified';\n        });\n        eventListener.listen('beforeinput', (event) => {\n            beforeinputEvent = event;\n            value = element.value;\n        });\n        eventListener.listen('input', (event) => {\n            if (isVirtualAndroidKeyboard &&\n                beforeinputEvent.defaultPrevented &&\n                beforeinputEvent.inputType === 'deleteContentBackward' &&\n                event.inputType === 'deleteContentBackward') {\n                element.value = value;\n            }\n        }, { capture: true });\n        return () => eventListener.destroy();\n    };\n}\n\nfunction maskitoChangeEventPlugin() {\n    return (element) => {\n        if (element.isContentEditable) {\n            return;\n        }\n        let value = element.value;\n        const valueListener = () => {\n            value = element.value;\n        };\n        const blurListener = () => {\n            if (element.value !== value) {\n                element.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n        };\n        element.addEventListener('focus', valueListener);\n        element.addEventListener('change', valueListener);\n        element.addEventListener('blur', blurListener);\n        return () => {\n            element.removeEventListener('focus', valueListener);\n            element.removeEventListener('change', valueListener);\n            element.removeEventListener('blur', blurListener);\n        };\n    };\n}\n\nconst SPACE = ' ';\n/**\n * 1. Android user (with G-board keyboard or similar) presses 1st space\n * ```\n * {type: \"beforeinput\", data: \" \", inputType: \"insertText\"}\n * ```\n * 2. User presses 2nd space\n * ```\n * // Android tries to delete previously inserted space\n * {type: \"beforeinput\", inputType: \"deleteContentBackward\"}\n * {type: \"beforeinput\", data: \". \", inputType: \"insertText\"}\n * ```\n * ---------\n * 1. MacOS user presses 1st space\n * ```\n * {type: \"beforeinput\", data: \" \", inputType: \"insertText\"}\n * ```\n * 2. User presses 2nd space\n * ```\n * // MacOS automatically run `element.setSelectionRange(indexBeforeSpace, indexAfterSpace)` and then\n * {type: \"beforeinput\", data: \". \", inputType: \"insertText\"}\n * ```\n * ---------\n * @see https://github.com/taiga-family/maskito/issues/2023\n */\nfunction createDoubleSpacePlugin() {\n    let prevValue = '';\n    let prevCaretIndex = 0;\n    let prevEvent = null;\n    let prevRejectedSpace = false;\n    return (element) => {\n        const eventListener = new EventListener(element);\n        eventListener.listen('beforeinput', (event) => {\n            var _a, _b;\n            const { value, selectionStart, selectionEnd } = element;\n            const rejectedSpace = (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.inputType) === 'insertText' &&\n                (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.data) === SPACE &&\n                !value.slice(0, Number(selectionEnd)).endsWith(SPACE);\n            if (event.inputType === 'insertText' && event.data === `.${SPACE}`) {\n                if ((prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.inputType) === 'deleteContentBackward' &&\n                    prevRejectedSpace) {\n                    // Android\n                    element.value = prevValue;\n                    (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, prevCaretIndex, prevCaretIndex);\n                }\n                else if (rejectedSpace) {\n                    // Mac OS\n                    (_b = element.setSelectionRange) === null || _b === void 0 ? void 0 : _b.call(element, selectionStart, selectionStart);\n                }\n            }\n            prevRejectedSpace = rejectedSpace;\n            prevEvent = event;\n            prevValue = value;\n            prevCaretIndex = Number((rejectedSpace ? prevCaretIndex : selectionEnd) === value.length\n                ? selectionEnd\n                : selectionStart);\n        });\n        return () => eventListener.destroy();\n    };\n}\n\nfunction maskitoInitialCalibrationPlugin(customOptions) {\n    return (element, options) => {\n        var _a, _b;\n        const from = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n        const to = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n        maskitoUpdateElement(element, {\n            value: maskitoTransform(element.value, customOptions || options),\n            selection: [from, to],\n        });\n    };\n}\n\nfunction maskitoStrictCompositionPlugin() {\n    return (element, maskitoOptions) => {\n        const listener = (event) => {\n            var _a, _b;\n            if (event.inputType !== 'insertCompositionText') {\n                return;\n            }\n            const selection = [\n                (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0,\n                (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0,\n            ];\n            const elementState = {\n                selection,\n                value: element.value,\n            };\n            const validatedState = maskitoTransform(elementState, maskitoOptions);\n            if (!areElementStatesEqual(elementState, validatedState)) {\n                event.preventDefault();\n                maskitoUpdateElement(element, validatedState);\n            }\n        };\n        element.addEventListener('input', listener);\n        return () => element.removeEventListener('input', listener);\n    };\n}\n\nconst BUILT_IN_PLUGINS = [createDoubleSpacePlugin(), createBrokenDefaultPlugin()];\nclass Maskito extends MaskHistory {\n    constructor(element, maskitoOptions) {\n        super();\n        this.element = element;\n        this.maskitoOptions = maskitoOptions;\n        this.isTextArea = this.element.nodeName === 'TEXTAREA';\n        this.eventListener = new EventListener(this.element);\n        this.options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), this.maskitoOptions);\n        this.upcomingElementState = null;\n        this.preprocessor = maskitoPipe(this.options.preprocessors);\n        this.postprocessor = maskitoPipe(this.options.postprocessors);\n        this.teardowns = this.options.plugins\n            .concat(BUILT_IN_PLUGINS)\n            .map((plugin) => plugin(this.element, this.options));\n        this.updateHistory(this.elementState);\n        this.eventListener.listen('keydown', (event) => {\n            if (isRedo(event)) {\n                event.preventDefault();\n                return this.redo();\n            }\n            if (isUndo(event)) {\n                event.preventDefault();\n                return this.undo();\n            }\n        });\n        this.eventListener.listen('beforeinput', (event) => {\n            var _a, _b, _c;\n            const isForward = event.inputType.includes('Forward');\n            this.updateHistory(this.elementState);\n            switch (event.inputType) {\n                case 'deleteByCut':\n                case 'deleteContentBackward':\n                case 'deleteContentForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getNotEmptySelection(this.elementState, isForward),\n                    });\n                case 'deleteHardLineBackward':\n                case 'deleteHardLineForward':\n                case 'deleteSoftLineBackward':\n                case 'deleteSoftLineForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getLineSelection(this.elementState, isForward),\n                        force: true,\n                    });\n                case 'deleteWordBackward':\n                case 'deleteWordForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getWordSelection(this.elementState, isForward),\n                    });\n                case 'historyRedo':\n                    event.preventDefault();\n                    return this.redo();\n                // historyUndo/historyRedo will not be triggered if value was modified programmatically\n                case 'historyUndo':\n                    event.preventDefault();\n                    return this.undo();\n                case 'insertCompositionText':\n                    return; // will be handled inside `compositionend` event\n                case 'insertLineBreak':\n                case 'insertParagraph':\n                    return this.handleEnter(event);\n                case 'insertReplacementText':\n                    /**\n                     * According {@link https://www.w3.org/TR/input-events-2 W3C specification}:\n                     * > `insertReplacementText` \u2013 insert or replace existing text by means of a spell checker,\n                     * > auto-correct, writing suggestions or similar.\n                     * ___\n                     * Firefox emits `insertReplacementText` event for its suggestion/autofill and for spell checker.\n                     * However, it is impossible to detect which part of the textfield value is going to be replaced\n                     * (`selectionStart` and `selectionEnd` just equal to the last caret position).\n                     * ___\n                     * Chrome does not fire `beforeinput` event for its suggestion/autofill.\n                     * It emits only `input` event with `inputType` and `data` set to `undefined`.\n                     * ___\n                     * All these browser limitations make us to validate the result value later in `input` event.\n                     */\n                    return;\n                case 'insertFromDrop':\n                case 'insertFromPaste':\n                case 'insertText':\n                default:\n                    return this.handleInsert(event, (_c = (_a = event.data) !== null && _a !== void 0 ? _a : \n                    // `event.data` for `contentEditable` is always `null` for paste/drop events\n                    (_b = event.dataTransfer) === null || _b === void 0 ? void 0 : _b.getData('text/plain')) !== null && _c !== void 0 ? _c : '');\n            }\n        });\n        this.eventListener.listen('input', () => {\n            if (this.upcomingElementState &&\n                !areElementStatesEqual(this.upcomingElementState, this.elementState)) {\n                this.updateElementState(this.upcomingElementState);\n            }\n            this.upcomingElementState = null;\n        }, { capture: true });\n        this.eventListener.listen('input', ({ inputType }) => {\n            if (inputType === 'insertCompositionText') {\n                return; // will be handled inside `compositionend` event\n            }\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n        this.eventListener.listen('compositionend', () => {\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n    }\n    destroy() {\n        this.eventListener.destroy();\n        this.teardowns.forEach((teardown) => teardown === null || teardown === void 0 ? void 0 : teardown());\n    }\n    updateElementState({ value, selection }, eventInit) {\n        const initialValue = this.elementState.value;\n        this.updateValue(value);\n        this.updateSelectionRange(selection);\n        if (eventInit && initialValue !== value) {\n            this.dispatchInputEvent(eventInit);\n        }\n    }\n    get elementState() {\n        const { value, selectionStart, selectionEnd } = this.element;\n        return {\n            value,\n            selection: [selectionStart !== null && selectionStart !== void 0 ? selectionStart : 0, selectionEnd !== null && selectionEnd !== void 0 ? selectionEnd : 0],\n        };\n    }\n    get maxLength() {\n        const { maxLength } = this.element;\n        return maxLength === -1 ? Infinity : maxLength;\n    }\n    updateSelectionRange([from, to]) {\n        var _a;\n        const { element } = this;\n        if (element.matches(':focus') &&\n            (element.selectionStart !== from || element.selectionEnd !== to)) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    updateValue(value) {\n        /**\n         * Don't \"disturb\" unnecessarily `value`-setter\n         * (i.e. it breaks React controlled input behavior)\n         */\n        if (this.element.value !== value || this.element.isContentEditable) {\n            this.element.value = value;\n        }\n    }\n    ensureValueFitsMask() {\n        this.updateElementState(maskitoTransform(this.elementState, this.options), {\n            inputType: 'insertText',\n            data: null,\n        });\n    }\n    dispatchInputEvent(eventInit = {\n        inputType: 'insertText',\n        data: null,\n    }) {\n        if (globalThis.InputEvent) {\n            this.element.dispatchEvent(new InputEvent('input', Object.assign(Object.assign({}, eventInit), { bubbles: true, cancelable: false })));\n        }\n    }\n    handleDelete({ event, selection, isForward, }) {\n        const initialState = {\n            value: this.elementState.value,\n            selection,\n        };\n        const { elementState } = this.preprocessor({\n            elementState: initialState,\n            data: '',\n        }, isForward ? 'deleteForward' : 'deleteBackward');\n        const maskModel = new MaskModel(elementState, this.options);\n        maskModel.deleteCharacters();\n        const newElementState = this.postprocessor(maskModel, initialState);\n        if (areElementValuesEqual(initialState, elementState, maskModel, newElementState)) {\n            const [from, to] = elementState.selection;\n            event.preventDefault();\n            // User presses Backspace/Delete for the fixed value\n            return this.updateSelectionRange(isForward ? [to, to] : [from, from]);\n        }\n        this.upcomingElementState = newElementState;\n    }\n    handleInsert(event, data) {\n        const { options, maxLength, elementState: initialElementState } = this;\n        const [from, to] = initialElementState.selection;\n        const { elementState, data: insertedText = data } = this.preprocessor({\n            data,\n            elementState: initialElementState,\n        }, 'insert');\n        const maskModel = new MaskModel(elementState, options);\n        try {\n            maskModel.addCharacters(insertedText);\n        }\n        catch (_a) {\n            return event.preventDefault();\n        }\n        this.upcomingElementState = this.clampState(this.postprocessor(maskModel, initialElementState));\n        /**\n         * When textfield value length is already equal to attribute `maxlength`,\n         * pressing any key (even with valid value) does not emit `input` event\n         * (except to the case when user replaces some characters by selection).\n         */\n        const noInputEventDispatch = initialElementState.value.length >= maxLength && from === to;\n        if (noInputEventDispatch) {\n            if (options.overwriteMode === 'replace' &&\n                !areElementStatesEqual(this.upcomingElementState, initialElementState)) {\n                this.dispatchInputEvent({ inputType: 'insertText', data });\n            }\n            else {\n                /**\n                 * This `beforeinput` event will not be followed by `input` event \u2013\n                 * clear computed state to avoid any possible side effect\n                 * for new possible `input` event without preceding `beforeinput` event\n                 * (e.g. browser autofill, `document.execCommand('delete')` etc.)\n                 */\n                this.upcomingElementState = null;\n            }\n        }\n    }\n    handleEnter(event) {\n        if (this.isTextArea || this.element.isContentEditable) {\n            this.handleInsert(event, '\\n');\n        }\n    }\n    clampState({ value, selection }) {\n        const [from, to] = selection;\n        const max = this.maxLength;\n        return {\n            value: value.slice(0, max),\n            selection: [Math.min(from, max), Math.min(to, max)],\n        };\n    }\n}\n\nexport { MASKITO_DEFAULT_ELEMENT_PREDICATE, MASKITO_DEFAULT_OPTIONS, Maskito, maskitoAdaptContentEditable, maskitoChangeEventPlugin, maskitoInitialCalibrationPlugin, maskitoPipe, maskitoStrictCompositionPlugin, maskitoTransform, maskitoUpdateElement };\n", "import { maskitoUpdateElement, MASKITO_DEFAULT_OPTIONS, maskitoTransform } from '@maskito/core';\n\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nfunction clamp(value, min, max) {\n    const clampedValue = Math.min(Number(max), Math.max(Number(min), Number(value)));\n    return (value instanceof Date ? new Date(clampedValue) : clampedValue);\n}\n\nfunction countDigits(str) {\n    return str.replaceAll(/\\W/g, '').length;\n}\n\nconst DATE_SEGMENTS_MAX_VALUES = {\n    day: 31,\n    month: 12,\n    year: 9999,\n};\n\n// eslint-disable-next-line i18n/no-russian-character\nconst DEFAULT_DECIMAL_PSEUDO_SEPARATORS = ['.', ',', '\u0431', '\u044E'];\n\nconst DEFAULT_MIN_DATE = new Date('0001-01-01T00:00');\nconst DEFAULT_MAX_DATE = new Date('9999-12-31T23:59:59.999');\n\nconst DEFAULT_TIME_SEGMENT_MAX_VALUES = {\n    hours: 23,\n    minutes: 59,\n    seconds: 59,\n    milliseconds: 999,\n};\nconst DEFAULT_TIME_SEGMENT_MIN_VALUES = {\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n};\n\n/**\n * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.\n */\nconst CHAR_NO_BREAK_SPACE = '\\u00A0';\n/**\n * {@link https://symbl.cc/en/200B/ Zero width space}.\n */\nconst CHAR_ZERO_WIDTH_SPACE = '\\u200B';\n/**\n * {@link https://unicode-table.com/en/2013/ EN dash}\n * is used to indicate a range of numbers or a span of time.\n * @example 2006\u20132022\n */\nconst CHAR_EN_DASH = '\\u2013';\n/**\n * {@link https://unicode-table.com/en/2014/ EM dash}\n * is used to mark a break in a sentence.\n * @example Taiga UI \u2014 powerful set of open source components for Angular\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!\n */\nconst CHAR_EM_DASH = '\\u2014';\n/**\n * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}\n * is used to combine words.\n * @example well-behaved\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!\n */\nconst CHAR_HYPHEN = '\\u002D';\n/**\n * {@link https://unicode-table.com/en/2212/ Minus}\n * is used as math operator symbol or before negative digits.\n * ---\n * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}\n */\nconst CHAR_MINUS = '\\u2212';\n/**\n * {@link https://symbl.cc/en/30FC/ Katakana-Hiragana Prolonged Sound Mark}\n * is used as prolonged sounds in Japanese.\n */\nconst CHAR_JP_HYPHEN = '\\u30FC';\n/**\n * {@link https://symbl.cc/en/003A/ Colon}\n * is a punctuation mark that connects parts of a text logically.\n * ---\n * is also used as separator in time.\n */\nconst CHAR_COLON = '\\u003A';\n/**\n * {@link https://symbl.cc/en/FF1A/ Full-width colon}\n * is a full-width punctuation mark used to separate parts of a text commonly in Japanese.\n */\nconst CHAR_JP_COLON = '\\uFF1A';\n\nconst ANY_MERIDIEM_CHARACTER_RE = new RegExp(`[${CHAR_NO_BREAK_SPACE}APM]+$`, 'g');\nconst ALL_MERIDIEM_CHARACTERS_RE = new RegExp(`${CHAR_NO_BREAK_SPACE}[AP]M$`, 'g');\n\nconst TIME_FIXED_CHARACTERS = [':', '.'];\n\nconst TIME_SEGMENT_VALUE_LENGTHS = {\n    hours: 2,\n    minutes: 2,\n    seconds: 2,\n    milliseconds: 3,\n};\n\nconst POSSIBLE_DATE_RANGE_SEPARATOR = [\n    CHAR_HYPHEN,\n    CHAR_EN_DASH,\n    CHAR_EM_DASH,\n    CHAR_MINUS,\n    CHAR_JP_HYPHEN,\n];\nconst MIN_DAY = 1;\nconst MONTHS_IN_YEAR = 12;\nconst MonthNumber = {\n    January: 0,\n    February: 1,\n    April: 3,\n    June: 5,\n    September: 8,\n    November: 10,\n    December: 11,\n};\n\nfunction appendDate(date, { day = 0, month = 0, year = 0 } = {}) {\n    if (day === 0 && month === 0 && year === 0) {\n        return date;\n    }\n    const initialYear = date.getFullYear();\n    const initialMonth = date.getMonth();\n    const initialDate = date.getDate();\n    const totalMonths = (initialYear + year) * MONTHS_IN_YEAR + initialMonth + month;\n    let years = Math.floor(totalMonths / MONTHS_IN_YEAR);\n    let months = totalMonths % MONTHS_IN_YEAR;\n    let days = Math.min(initialDate, getMonthDaysCount(months, isLeapYear(years))) + day;\n    while (days > getMonthDaysCount(months, isLeapYear(years))) {\n        days -= getMonthDaysCount(months, isLeapYear(years));\n        if (months === MonthNumber.December) {\n            years++;\n            months = MonthNumber.January;\n        }\n        else {\n            months++;\n        }\n    }\n    while (days < MIN_DAY) {\n        if (months === MonthNumber.January) {\n            years--;\n            months = MonthNumber.December;\n        }\n        else {\n            months--;\n        }\n        days += getMonthDaysCount(months, isLeapYear(years));\n    }\n    days =\n        day < 0 || (day === 0 && isLeapYear(initialYear) && (month < 0 || year < 0))\n            ? days + 1 // add one day when moving days backward, or months or years backward for leap year\n            : days - 1; // \"from\"-day is included in the range\n    return new Date(years, months, days);\n}\nfunction getMonthDaysCount(month, isLeapYear) {\n    switch (month) {\n        case MonthNumber.April:\n        case MonthNumber.June:\n        case MonthNumber.November:\n        case MonthNumber.September:\n            return 30;\n        case MonthNumber.February:\n            return isLeapYear ? 29 : 28;\n        default:\n            return 31;\n    }\n}\nfunction isLeapYear(year) {\n    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n}\n\nconst getDateSegmentValueLength = (dateString) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        day: (_b = (_a = dateString.match(/d/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,\n        month: (_d = (_c = dateString.match(/m/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\n        year: (_f = (_e = dateString.match(/y/g)) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0,\n    });\n};\n\nfunction dateToSegments(date) {\n    return {\n        day: String(date.getDate()).padStart(2, '0'),\n        month: String(date.getMonth() + 1).padStart(2, '0'),\n        year: String(date.getFullYear()).padStart(4, '0'),\n        hours: String(date.getHours()).padStart(2, '0'),\n        minutes: String(date.getMinutes()).padStart(2, '0'),\n        seconds: String(date.getSeconds()).padStart(2, '0'),\n        milliseconds: String(date.getMilliseconds()).padStart(3, '0'),\n    };\n}\n\nconst ALL_POSSIBLE_SEGMENTS = [\n    'day',\n    'month',\n    'year',\n];\nfunction getDateSegmentsOrder(template) {\n    return [...ALL_POSSIBLE_SEGMENTS].sort((a, b) => template.indexOf(a[0]) > template.indexOf(b[0]) ? 1 : -1);\n}\n\nfunction getFirstCompleteDate(dateString, dateModeTemplate) {\n    const digitsInDate = countDigits(dateModeTemplate);\n    const [completeDate = ''] = new RegExp(`(\\\\D*\\\\d){${digitsInDate}}`).exec(dateString) || [];\n    return completeDate;\n}\n\nfunction isDateStringComplete(dateString, dateModeTemplate) {\n    if (dateString.length < dateModeTemplate.length) {\n        return false;\n    }\n    return dateString.split(/\\D/).every((segment) => !/^0+$/.exec(segment));\n}\n\nfunction parseDateRangeString(dateRange, dateModeTemplate, rangeSeparator) {\n    const digitsInDate = countDigits(dateModeTemplate);\n    return (dateRange\n        .replace(rangeSeparator, '')\n        .match(new RegExp(`(\\\\D*\\\\d[^\\\\d\\\\s]*){1,${digitsInDate}}`, 'g')) || []);\n}\n\nfunction parseDateString(dateString, fullMode) {\n    const cleanMode = fullMode.replaceAll(/[^dmy]/g, '');\n    const onlyDigitsDate = dateString.replaceAll(/\\D+/g, '');\n    const dateSegments = {\n        day: onlyDigitsDate.slice(cleanMode.indexOf('d'), cleanMode.lastIndexOf('d') + 1),\n        month: onlyDigitsDate.slice(cleanMode.indexOf('m'), cleanMode.lastIndexOf('m') + 1),\n        year: onlyDigitsDate.slice(cleanMode.indexOf('y'), cleanMode.lastIndexOf('y') + 1),\n    };\n    return Object.fromEntries(Object.entries(dateSegments)\n        .filter(([_, value]) => Boolean(value))\n        .sort(([a], [b]) => fullMode.toLowerCase().indexOf(a.slice(0, 1)) >\n        fullMode.toLowerCase().indexOf(b.slice(0, 1))\n        ? 1\n        : -1));\n}\n\nfunction segmentsToDate(parsedDate, parsedTime) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const year = ((_a = parsedDate.year) === null || _a === void 0 ? void 0 : _a.length) === 2 ? `20${parsedDate.year}` : parsedDate.year;\n    const date = new Date(Number(year !== null && year !== void 0 ? year : '0'), Number((_b = parsedDate.month) !== null && _b !== void 0 ? _b : '1') - 1, Number((_c = parsedDate.day) !== null && _c !== void 0 ? _c : '1'), Number((_d = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.hours) !== null && _d !== void 0 ? _d : '0'), Number((_e = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.minutes) !== null && _e !== void 0 ? _e : '0'), Number((_f = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.seconds) !== null && _f !== void 0 ? _f : '0'), Number((_g = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.milliseconds) !== null && _g !== void 0 ? _g : '0'));\n    // needed for years less than 1900\n    date.setFullYear(Number(year !== null && year !== void 0 ? year : '0'));\n    return date;\n}\n\nconst DATE_TIME_SEPARATOR = ', ';\n\nfunction toDateString({ day, month, year, hours, minutes, seconds, milliseconds, }, { dateMode, dateTimeSeparator = DATE_TIME_SEPARATOR, timeMode, }) {\n    var _a;\n    const safeYear = ((_a = dateMode.match(/y/g)) === null || _a === void 0 ? void 0 : _a.length) === 2 ? year === null || year === void 0 ? void 0 : year.slice(-2) : year;\n    const fullMode = dateMode + (timeMode ? dateTimeSeparator + timeMode : '');\n    return fullMode\n        .replaceAll(/d+/g, day !== null && day !== void 0 ? day : '')\n        .replaceAll(/m+/g, month !== null && month !== void 0 ? month : '')\n        .replaceAll(/y+/g, safeYear !== null && safeYear !== void 0 ? safeYear : '')\n        .replaceAll(/H+/g, hours !== null && hours !== void 0 ? hours : '')\n        .replaceAll('MSS', milliseconds !== null && milliseconds !== void 0 ? milliseconds : '')\n        .replaceAll(/M+/g, minutes !== null && minutes !== void 0 ? minutes : '')\n        .replaceAll(/S+/g, seconds !== null && seconds !== void 0 ? seconds : '')\n        .replaceAll(/^\\D+/g, '')\n        .replaceAll(/\\D+$/g, '');\n}\n\nfunction validateDateString({ dateString, dateModeTemplate, dateSegmentsSeparator, offset, selection: [from, to], }) {\n    var _a, _b;\n    const parsedDate = parseDateString(dateString, dateModeTemplate);\n    const dateSegments = Object.entries(parsedDate);\n    const segmentsOrder = getDateSegmentsOrder(dateModeTemplate);\n    const validatedDateSegments = {};\n    for (let i = 0; i < dateSegments.length; i++) {\n        const [segmentName, segmentValue] = dateSegments[i];\n        const validatedDate = toDateString(validatedDateSegments, {\n            dateMode: dateModeTemplate,\n        });\n        const maxSegmentValue = DATE_SEGMENTS_MAX_VALUES[segmentName];\n        const fantomSeparator = validatedDate.length && dateSegmentsSeparator.length;\n        const lastSegmentDigitIndex = offset +\n            validatedDate.length +\n            fantomSeparator +\n            getDateSegmentValueLength(dateModeTemplate)[segmentName];\n        const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex === to;\n        if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n            const nextSegment = segmentsOrder[segmentsOrder.indexOf(segmentName) + 1];\n            if (!nextSegment || nextSegment === 'year') {\n                // 31.1|0.2010 => Type 9 => 31.1|0.2010\n                return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes\n            }\n            validatedDateSegments[segmentName] = `0${segmentValue.slice(0, -1)}`;\n            dateSegments[i + 1] = [\n                nextSegment,\n                segmentValue.slice(-1) + ((_b = (_a = dateSegments[i + 1]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '').slice(1),\n            ];\n            continue;\n        }\n        if (isLastSegmentDigitAdded && Number(segmentValue) < 1) {\n            // 31.0|1.2010 => Type 0 => 31.0|1.2010\n            return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes\n        }\n        validatedDateSegments[segmentName] = segmentValue;\n    }\n    const validatedDateString = toDateString(validatedDateSegments, {\n        dateMode: dateModeTemplate,\n    });\n    const addedDateSegmentSeparators = validatedDateString.length - dateString.length;\n    return {\n        validatedDateString,\n        updatedSelection: [\n            from + addedDateSegmentSeparators,\n            to + addedDateSegmentSeparators,\n        ],\n    };\n}\n\nfunction identity(x) {\n    return x;\n}\n// eslint-disable-next-line  @typescript-eslint/no-empty-function\nfunction noop() { }\n\n/**\n * Copy-pasted solution from lodash\n * @see https://lodash.com/docs/4.17.15#escapeRegExp\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nconst reHasRegExpChar = new RegExp(reRegExpChar.source);\nfunction escapeRegExp(str) {\n    return str && reHasRegExpChar.test(str)\n        ? str.replaceAll(reRegExpChar, String.raw `\\$&`)\n        : str;\n}\n\nfunction extractAffixes(value, { prefix, postfix }) {\n    var _a, _b;\n    const prefixRegExp = new RegExp(`^${escapeRegExp(prefix)}`);\n    const postfixRegExp = new RegExp(`${escapeRegExp(postfix)}$`);\n    const [extractedPrefix = ''] = (_a = value.match(prefixRegExp)) !== null && _a !== void 0 ? _a : [];\n    const [extractedPostfix = ''] = (_b = value.match(postfixRegExp)) !== null && _b !== void 0 ? _b : [];\n    return {\n        extractedPrefix,\n        extractedPostfix,\n        cleanValue: extractedPrefix || extractedPostfix\n            ? value.slice(extractedPrefix.length, extractedPostfix.length ? -extractedPostfix.length : Infinity)\n            : value,\n    };\n}\n\nfunction findCommonBeginningSubstr(a, b) {\n    let res = '';\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return res;\n        }\n        res += a[i];\n    }\n    return res;\n}\n\nfunction isEmpty(entity) {\n    return !entity || (typeof entity === 'object' && Object.keys(entity).length === 0);\n}\n\nconst ALL_ZEROES_RE = /^0+$/;\nfunction padWithZeroesUntilValid(segmentValue, paddedMaxValue, prefixedZeroesCount = 0) {\n    const paddedSegmentValue = segmentValue.padEnd(paddedMaxValue.length, '0');\n    if (Number(paddedSegmentValue) <= Number(paddedMaxValue)) {\n        return { validatedSegmentValue: segmentValue, prefixedZeroesCount };\n    }\n    if (paddedSegmentValue.endsWith('0')) {\n        // 00:|00 => Type 9 => 00:09|\n        return padWithZeroesUntilValid(`0${segmentValue.slice(0, paddedMaxValue.length - 1)}`, paddedMaxValue, prefixedZeroesCount + 1);\n    }\n    const valueWithoutLastChar = segmentValue.slice(0, paddedMaxValue.length - 1);\n    if (ALL_ZEROES_RE.exec(valueWithoutLastChar)) {\n        return { validatedSegmentValue: '', prefixedZeroesCount };\n    }\n    // |19:00 => Type 2 => 2|0:00\n    return padWithZeroesUntilValid(`${valueWithoutLastChar}0`, paddedMaxValue, prefixedZeroesCount);\n}\n\n/**\n * Replace fullwidth colon with half width colon\n * @param fullWidthColon full width colon\n * @returns processed half width colon\n */\nfunction toHalfWidthColon(fullWidthColon) {\n    return fullWidthColon.replaceAll(new RegExp(CHAR_JP_COLON, 'g'), CHAR_COLON);\n}\n\n/**\n * Replace fullwidth numbers with half width number\n * @param fullWidthNumber full width number\n * @returns processed half width number\n */\nfunction toHalfWidthNumber(fullWidthNumber) {\n    return fullWidthNumber.replaceAll(/[\uFF10-\uFF19]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0));\n}\n\n/**\n * Convert full width colon (\uFF1A) to half width one (:)\n */\nfunction createColonConvertPreprocessor() {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        return {\n            elementState: {\n                selection,\n                value: toHalfWidthColon(value),\n            },\n            data: toHalfWidthColon(data),\n        };\n    };\n}\n\nfunction createDateSegmentsZeroPaddingPostprocessor({ dateModeTemplate, dateSegmentSeparator, splitFn, uniteFn, }) {\n    return ({ value, selection }) => {\n        var _a;\n        const [from, to] = selection;\n        const { dateStrings, restPart = '' } = splitFn(value);\n        const validatedDateStrings = [];\n        let caretShift = 0;\n        dateStrings.forEach((dateString) => {\n            const parsedDate = parseDateString(dateString, dateModeTemplate);\n            const dateSegments = Object.entries(parsedDate);\n            const validatedDateSegments = dateSegments.reduce((acc, [segmentName, segmentValue]) => {\n                const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, `${DATE_SEGMENTS_MAX_VALUES[segmentName]}`);\n                caretShift += prefixedZeroesCount;\n                return Object.assign(Object.assign({}, acc), { [segmentName]: validatedSegmentValue });\n            }, {});\n            validatedDateStrings.push(toDateString(validatedDateSegments, { dateMode: dateModeTemplate }));\n        });\n        const validatedValue = uniteFn(validatedDateStrings, value) +\n            (((_a = dateStrings[dateStrings.length - 1]) === null || _a === void 0 ? void 0 : _a.endsWith(dateSegmentSeparator))\n                ? dateSegmentSeparator\n                : '') +\n            restPart;\n        if (caretShift &&\n            validatedValue.slice(to + caretShift, to + caretShift + dateSegmentSeparator.length) === dateSegmentSeparator) {\n            /**\n             * If `caretShift` > 0, it means that time segment was padded with zero.\n             * It is only possible if any character insertion happens.\n             * If caret is before `dateSegmentSeparator` => it should be moved after `dateSegmentSeparator`.\n             */\n            caretShift += dateSegmentSeparator.length;\n        }\n        return {\n            selection: [from + caretShift, to + caretShift],\n            value: validatedValue,\n        };\n    };\n}\n\n/**\n * It replaces pseudo range separators with valid one.\n * @example '01.01.2000_11.11.2000' -> '01.01.2000 - 01.01.2000'\n * @example '01.01.2000_23:59' -> '01.01.2000, 23:59'\n */\nfunction createFirstDateEndSeparatorPreprocessor({ dateModeTemplate, firstDateEndSeparator, dateSegmentSeparator, pseudoFirstDateEndSeparators, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const firstCompleteDate = getFirstCompleteDate(value, dateModeTemplate);\n        const pseudoSeparators = pseudoFirstDateEndSeparators.filter((x) => !firstDateEndSeparator.includes(x) && x !== dateSegmentSeparator);\n        const pseudoSeparatorsRE = new RegExp(`[${pseudoSeparators.join('')}]`, 'gi');\n        const newValue = firstCompleteDate && value.length > firstCompleteDate.length\n            ? firstCompleteDate +\n                value\n                    .slice(firstCompleteDate.length)\n                    .replace(/^[\\D\\s]*/, firstDateEndSeparator)\n            : value;\n        const caretShift = newValue.length - value.length;\n        return {\n            elementState: {\n                selection: [from + caretShift, to + caretShift],\n                value: newValue,\n            },\n            data: data.replace(pseudoSeparatorsRE, firstDateEndSeparator),\n        };\n    };\n}\n\n/**\n * Convert full width numbers like \uFF11, \uFF12 to half width numbers 1, 2\n */\nfunction createFullWidthToHalfWidthPreprocessor() {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        return {\n            elementState: {\n                selection,\n                value: toHalfWidthNumber(value),\n            },\n            data: toHalfWidthNumber(data),\n        };\n    };\n}\n\nfunction createTimeMaskExpression(mode) {\n    return Array.from(mode.replace(' AA', ''))\n        .map((char) => (TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/))\n        .concat(mode.includes('AA') ? [CHAR_NO_BREAK_SPACE, /[AP]/i, /M/i] : []);\n}\n\nfunction padTimeSegments(timeSegments, pad) {\n    return Object.fromEntries(Object.entries(timeSegments).map(([segmentName, segmentValue]) => [\n        segmentName,\n        pad(String(segmentValue), TIME_SEGMENT_VALUE_LENGTHS[segmentName]),\n    ]));\n}\n\nfunction padStartTimeSegments(timeSegments) {\n    return padTimeSegments(timeSegments, (value, length) => value.padStart(length, '0'));\n}\n\nconst SEGMENT_FULL_NAME = {\n    HH: 'hours',\n    MM: 'minutes',\n    SS: 'seconds',\n    MSS: 'milliseconds',\n};\n/**\n * @param timeString can be with/without fixed characters\n */\nfunction parseTimeString(timeString, timeMode) {\n    const onlyDigits = timeString.replaceAll(/\\D+/g, '');\n    let offset = 0;\n    return Object.fromEntries(timeMode\n        .split(/\\W/)\n        .filter((segmentAbbr) => SEGMENT_FULL_NAME[segmentAbbr])\n        .map((segmentAbbr) => {\n        const segmentValue = onlyDigits.slice(offset, offset + segmentAbbr.length);\n        offset += segmentAbbr.length;\n        return [SEGMENT_FULL_NAME[segmentAbbr], segmentValue];\n    }));\n}\n\nconst LEADING_NON_DIGITS = /^\\D*/;\nconst TRAILING_NON_DIGITS = /\\D*$/;\nfunction toTimeString({ hours = '', minutes = '', seconds = '', milliseconds = '', }) {\n    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n        .replace(LEADING_NON_DIGITS, '')\n        .replace(TRAILING_NON_DIGITS, '');\n}\n\nconst TRAILING_TIME_SEGMENT_SEPARATOR_REG = new RegExp(`[${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]$`);\n/**\n * Pads invalid time segment with zero to make it valid.\n * @example 00:|00 => Type 9 (too much for the first digit of minutes) => 00:09|\n * @example |19:00 => Type 2 (29 - invalid value for hours) => 2|0:00\n */\nfunction enrichTimeSegmentsWithZeroes({ value, selection }, { mode, timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES, }) {\n    const [from, to] = selection;\n    const parsedTime = parseTimeString(value, mode);\n    const possibleTimeSegments = Object.entries(parsedTime);\n    const paddedMaxValues = padStartTimeSegments(timeSegmentMaxValues);\n    const validatedTimeSegments = {};\n    let paddedZeroes = 0;\n    for (const [segmentName, segmentValue] of possibleTimeSegments) {\n        const maxSegmentValue = paddedMaxValues[segmentName];\n        const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, String(maxSegmentValue));\n        paddedZeroes += prefixedZeroesCount;\n        validatedTimeSegments[segmentName] = validatedSegmentValue;\n    }\n    const [leadingNonDigitCharacters = ''] = value.match(/^\\D+(?=\\d)/g) || []; // prefix\n    const [trailingNonDigitCharacters = ''] = value.match(/\\D+$/g) || []; // trailing segment separators / meridiem characters / postfix\n    const validatedTimeString = leadingNonDigitCharacters +\n        toTimeString(validatedTimeSegments) +\n        trailingNonDigitCharacters;\n    const addedDateSegmentSeparators = Math.max(validatedTimeString.length - value.length - paddedZeroes, 0);\n    let newFrom = from + paddedZeroes + addedDateSegmentSeparators;\n    let newTo = to + paddedZeroes + addedDateSegmentSeparators;\n    if (newFrom === newTo &&\n        paddedZeroes &&\n        // if next character after cursor is time segment separator\n        validatedTimeString.slice(0, newTo + 1).match(TRAILING_TIME_SEGMENT_SEPARATOR_REG)) {\n        newFrom++;\n        newTo++;\n    }\n    return {\n        value: validatedTimeString,\n        selection: [newFrom, newTo],\n    };\n}\n\nfunction padEndTimeSegments(timeSegments) {\n    return padTimeSegments(timeSegments, (value, length) => value.padEnd(length, '0'));\n}\n\n/**\n * Prevent insertion if any time segment will become invalid\n * (and even zero padding won't help with it).\n * @example 2|0:00 => Type 9 => 2|0:00\n */\nfunction createInvalidTimeSegmentInsertionPreprocessor({ timeMode, timeSegmentMinValues = DEFAULT_TIME_SEGMENT_MIN_VALUES, timeSegmentMaxValues = DEFAULT_TIME_SEGMENT_MAX_VALUES, parseValue = (x) => ({ timeString: x }), }) {\n    const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]+`);\n    return ({ elementState, data }, actionType) => {\n        if (actionType !== 'insert') {\n            return { elementState, data };\n        }\n        const { value, selection } = elementState;\n        const [from, rawTo] = selection;\n        const newCharacters = data.replace(invalidCharsRegExp, '');\n        const to = rawTo + newCharacters.length; // to be conformed with `overwriteMode: replace`\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const { timeString, restValue = '' } = parseValue(newPossibleValue);\n        const timeSegments = Object.entries(parseTimeString(timeString, timeMode));\n        let offset = restValue.length;\n        for (const [segmentName, stringifiedSegmentValue] of timeSegments) {\n            const minSegmentValue = timeSegmentMinValues[segmentName];\n            const maxSegmentValue = timeSegmentMaxValues[segmentName];\n            const segmentValue = Number(stringifiedSegmentValue);\n            const lastSegmentDigitIndex = offset + TIME_SEGMENT_VALUE_LENGTHS[segmentName];\n            if (lastSegmentDigitIndex >= from &&\n                lastSegmentDigitIndex <= to &&\n                segmentValue !== clamp(segmentValue, minSegmentValue, maxSegmentValue)) {\n                return { elementState, data: '' }; // prevent insertion\n            }\n            offset +=\n                stringifiedSegmentValue.length +\n                    // any time segment separator\n                    1;\n        }\n        return { elementState, data };\n    };\n}\n\nfunction createMeridiemPreprocessor(timeMode) {\n    if (!timeMode.includes('AA')) {\n        return identity;\n    }\n    const mainMeridiemCharRE = /^[AP]$/gi;\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const newValue = value.toUpperCase();\n        const newData = data.toUpperCase();\n        if (newValue.match(ALL_MERIDIEM_CHARACTERS_RE) &&\n            newData.match(mainMeridiemCharRE)) {\n            return {\n                elementState: {\n                    value: newValue.replaceAll(ALL_MERIDIEM_CHARACTERS_RE, ''),\n                    selection,\n                },\n                data: `${newData}M`,\n            };\n        }\n        return { elementState: { selection, value: newValue }, data: newData };\n    };\n}\nfunction createMeridiemPostprocessor(timeMode) {\n    if (!timeMode.includes('AA')) {\n        return identity;\n    }\n    return ({ value, selection }, initialElementState) => {\n        if (!value.match(ANY_MERIDIEM_CHARACTER_RE) ||\n            value.match(ALL_MERIDIEM_CHARACTERS_RE)) {\n            return { value, selection };\n        }\n        const [from, to] = selection;\n        // any meridiem character was deleted\n        if (initialElementState.value.match(ALL_MERIDIEM_CHARACTERS_RE)) {\n            const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, '');\n            return {\n                value: newValue,\n                selection: [\n                    Math.min(from, newValue.length),\n                    Math.min(to, newValue.length),\n                ],\n            };\n        }\n        const fullMeridiem = `${CHAR_NO_BREAK_SPACE}${value.includes('P') ? 'P' : 'A'}M`;\n        const newValue = value.replace(ANY_MERIDIEM_CHARACTER_RE, (x) => x !== CHAR_NO_BREAK_SPACE ? fullMeridiem : x);\n        return {\n            value: newValue,\n            selection: to >= newValue.indexOf(fullMeridiem)\n                ? [newValue.length, newValue.length]\n                : selection,\n        };\n    };\n}\n\nfunction raiseSegmentValueToMin(segments, fullMode) {\n    const segmentsLength = getDateSegmentValueLength(fullMode);\n    return Object.fromEntries(Object.entries(segments).map(([key, value]) => {\n        const segmentLength = segmentsLength[key];\n        return [\n            key,\n            value.length === segmentLength && /^0+$/.exec(value)\n                ? '1'.padStart(segmentLength, '0')\n                : value,\n        ];\n    }));\n}\n\nconst LEAP_YEAR = '1972';\nfunction createMinMaxDatePostprocessor({ dateModeTemplate, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, rangeSeparator = '', dateSegmentSeparator = '.', }) {\n    return ({ value, selection }) => {\n        const endsWithRangeSeparator = rangeSeparator && value.endsWith(rangeSeparator);\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        let validatedValue = '';\n        for (const dateString of dateStrings) {\n            validatedValue += validatedValue ? rangeSeparator : '';\n            const parsedDate = parseDateString(dateString, dateModeTemplate);\n            if (!isDateStringComplete(dateString, dateModeTemplate)) {\n                const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n                const fixedValue = toDateString(fixedDate, { dateMode: dateModeTemplate });\n                const tail = dateString.endsWith(dateSegmentSeparator)\n                    ? dateSegmentSeparator\n                    : '';\n                validatedValue += fixedValue + tail;\n                continue;\n            }\n            const date = segmentsToDate(Object.assign({ year: LEAP_YEAR }, parsedDate));\n            const clampedDate = clamp(date, min, max);\n            validatedValue += toDateString(dateToSegments(clampedDate), {\n                dateMode: dateModeTemplate,\n            });\n        }\n        return {\n            selection,\n            value: validatedValue + (endsWithRangeSeparator ? rangeSeparator : ''),\n        };\n    };\n}\n\nfunction normalizeDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    return ({ elementState, data }) => {\n        const templateSegments = dateModeTemplate.split(dateSegmentsSeparator);\n        const includesTime = data.includes(dateTimeSeparator);\n        const dateSegments = data\n            .slice(0, includesTime ? data.indexOf(dateTimeSeparator) : Infinity)\n            .split(/\\D/)\n            .filter(Boolean);\n        if (!dateSegments.length || dateSegments.length % templateSegments.length !== 0) {\n            return { elementState, data };\n        }\n        const dates = dateSegments.reduce((dates, segment, index) => {\n            var _a;\n            const template = (_a = templateSegments[index % templateSegments.length]) !== null && _a !== void 0 ? _a : '';\n            const dateIndex = Math.trunc(index / templateSegments.length);\n            const isLastDateSegment = index % templateSegments.length === templateSegments.length - 1;\n            if (!dates[dateIndex]) {\n                dates[dateIndex] = '';\n            }\n            dates[dateIndex] += isLastDateSegment\n                ? segment\n                : `${segment.padStart(template.length, '0')}${dateSegmentsSeparator}`;\n            return dates;\n        }, []);\n        return {\n            elementState,\n            data: includesTime\n                ? `${dates[0]}${data.slice(data.indexOf(dateTimeSeparator))}`\n                : dates.join(rangeSeparator),\n        };\n    };\n}\n\nfunction maskitoPostfixPostprocessorGenerator(postfix) {\n    const postfixRE = new RegExp(`${escapeRegExp(postfix)}$`);\n    return postfix\n        ? ({ value, selection }, initialElementState) => {\n            if (!value && !initialElementState.value.endsWith(postfix)) {\n                // cases when developer wants input to be empty (programmatically)\n                return { value, selection };\n            }\n            if (!value.endsWith(postfix) &&\n                !initialElementState.value.endsWith(postfix)) {\n                return { selection, value: value + postfix };\n            }\n            const initialValueBeforePostfix = initialElementState.value.replace(postfixRE, '');\n            const postfixWasModified = initialElementState.selection[1] > initialValueBeforePostfix.length;\n            const alreadyExistedValueBeforePostfix = findCommonBeginningSubstr(initialValueBeforePostfix, value);\n            return {\n                selection,\n                value: Array.from(postfix)\n                    .reverse()\n                    .reduce((newValue, char, index) => {\n                    const i = newValue.length - 1 - index;\n                    const isInitiallyMirroredChar = alreadyExistedValueBeforePostfix[i] === char &&\n                        postfixWasModified;\n                    return newValue[i] !== char || isInitiallyMirroredChar\n                        ? newValue.slice(0, i + 1) + char + newValue.slice(i + 1)\n                        : newValue;\n                }, value),\n            };\n        }\n        : identity;\n}\n\nfunction maskitoPrefixPostprocessorGenerator(prefix) {\n    return prefix\n        ? ({ value, selection }, initialElementState) => {\n            if (value.startsWith(prefix) || // already valid\n                (!value && !initialElementState.value.startsWith(prefix)) // cases when developer wants input to be empty\n            ) {\n                return { value, selection };\n            }\n            const [from, to] = selection;\n            const prefixedValue = Array.from(prefix).reduce((modifiedValue, char, i) => modifiedValue[i] === char\n                ? modifiedValue\n                : modifiedValue.slice(0, i) + char + modifiedValue.slice(i), value);\n            const addedCharsCount = prefixedValue.length - value.length;\n            return {\n                selection: [from + addedCharsCount, to + addedCharsCount],\n                value: prefixedValue,\n            };\n        }\n        : identity;\n}\n\nfunction createValidDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        if (data === dateSegmentsSeparator) {\n            return {\n                elementState,\n                data: selection[0] === value.length ? data : '',\n            };\n        }\n        if (!data.replaceAll(/\\D/g, '')) {\n            return { elementState, data };\n        }\n        const newCharacters = data.replaceAll(new RegExp(`[^\\\\d${escapeRegExp(dateSegmentsSeparator)}${rangeSeparator}]`, 'g'), '');\n        const [from, rawTo] = selection;\n        let to = rawTo + data.length;\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const dateStrings = parseDateRangeString(newPossibleValue, dateModeTemplate, rangeSeparator);\n        let validatedValue = '';\n        const hasRangeSeparator = Boolean(rangeSeparator) && newPossibleValue.includes(rangeSeparator);\n        for (const dateString of dateStrings) {\n            const { validatedDateString, updatedSelection } = validateDateString({\n                dateString,\n                dateModeTemplate,\n                dateSegmentsSeparator,\n                offset: validatedValue.length,\n                selection: [from, to],\n            });\n            if (dateString && !validatedDateString) {\n                return { elementState, data: '' }; // prevent changes\n            }\n            to = updatedSelection[1];\n            validatedValue +=\n                hasRangeSeparator && !validatedValue\n                    ? validatedDateString + rangeSeparator\n                    : validatedDateString;\n        }\n        const newData = validatedValue.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedValue.slice(0, from) +\n                    newData\n                        .split(dateSegmentsSeparator)\n                        .map((segment) => '0'.repeat(segment.length))\n                        .join(dateSegmentsSeparator) +\n                    validatedValue.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoEventHandler(name, handler, eventListenerOptions) {\n    return (element, maskitoOptions) => {\n        const listener = () => handler(element, maskitoOptions);\n        element.addEventListener(name, listener, eventListenerOptions);\n        return () => element.removeEventListener(name, listener, eventListenerOptions);\n    };\n}\n\nfunction maskitoAddOnFocusPlugin(value) {\n    return maskitoEventHandler('focus', (element) => {\n        if (!element.value) {\n            maskitoUpdateElement(element, value);\n        }\n    });\n}\n\nfunction maskitoSelectionChangeHandler(handler) {\n    return (element, options) => {\n        const document = element.ownerDocument;\n        let isPointerDown = 0;\n        const onPointerDown = () => isPointerDown++;\n        const onPointerUp = () => {\n            isPointerDown = Math.max(--isPointerDown, 0);\n        };\n        const listener = () => {\n            if (!element.matches(':focus')) {\n                return;\n            }\n            if (isPointerDown) {\n                return document.addEventListener('mouseup', listener, {\n                    once: true,\n                    passive: true,\n                });\n            }\n            handler(element, options);\n        };\n        document.addEventListener('selectionchange', listener, { passive: true });\n        // Safari does not fire `selectionchange` on focus after programmatic update of textfield value\n        element.addEventListener('focus', listener, { passive: true });\n        element.addEventListener('mousedown', onPointerDown, { passive: true });\n        document.addEventListener('mouseup', onPointerUp, { passive: true });\n        return () => {\n            document.removeEventListener('selectionchange', listener);\n            element.removeEventListener('focus', listener);\n            element.removeEventListener('mousedown', onPointerDown);\n            document.removeEventListener('mouseup', onPointerUp);\n        };\n    };\n}\n\nfunction maskitoCaretGuard(guard) {\n    return maskitoSelectionChangeHandler((element) => {\n        var _a, _b;\n        const start = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = element.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n        const [fromLimit, toLimit] = guard(element.value, [start, end]);\n        if (fromLimit > start || toLimit < end) {\n            element.setSelectionRange(clamp(start, fromLimit, toLimit), clamp(end, fromLimit, toLimit));\n        }\n    });\n}\n\nconst maskitoRejectEvent = (element) => {\n    const listener = () => {\n        const value = element.value;\n        element.addEventListener('beforeinput', (event) => {\n            if (event.defaultPrevented && value === element.value) {\n                element.dispatchEvent(new CustomEvent('maskitoReject', { bubbles: true }));\n            }\n        }, { once: true });\n    };\n    element.addEventListener('beforeinput', listener, true);\n    return () => element.removeEventListener('beforeinput', listener, true);\n};\n\nfunction maskitoRemoveOnBlurPlugin(value) {\n    return maskitoEventHandler('blur', (element) => {\n        if (element.value === value) {\n            maskitoUpdateElement(element, '');\n        }\n    });\n}\n\nfunction createMeridiemSteppingPlugin(meridiemStartIndex) {\n    if (meridiemStartIndex < 0) {\n        return noop;\n    }\n    return (element) => {\n        const listener = (event) => {\n            const caretIndex = Number(element.selectionStart);\n            const value = element.value.toUpperCase();\n            if ((event.key !== 'ArrowUp' && event.key !== 'ArrowDown') ||\n                caretIndex < meridiemStartIndex) {\n                return;\n            }\n            event.preventDefault();\n            // eslint-disable-next-line no-nested-ternary\n            const meridiemMainCharacter = value.includes('A')\n                ? 'P'\n                : value.includes('P') || event.key === 'ArrowUp'\n                    ? 'A'\n                    : 'P';\n            const newMeridiem = `${CHAR_NO_BREAK_SPACE}${meridiemMainCharacter}M`;\n            maskitoUpdateElement(element, {\n                value: value.length === meridiemStartIndex\n                    ? value + newMeridiem\n                    : value.replace(ANY_MERIDIEM_CHARACTER_RE, newMeridiem),\n                selection: [caretIndex, caretIndex],\n            });\n        };\n        element.addEventListener('keydown', listener);\n        return () => element.removeEventListener('keydown', listener);\n    };\n}\n\nfunction createTimeSegmentsSteppingPlugin({ step, fullMode, timeSegmentMaxValues, }) {\n    const segmentsIndexes = createTimeSegmentsIndexes(fullMode);\n    return step <= 0\n        ? noop\n        : (element) => {\n            const listener = (event) => {\n                var _a;\n                if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n                    return;\n                }\n                event.preventDefault();\n                const selectionStart = (_a = element.selectionStart) !== null && _a !== void 0 ? _a : 0;\n                const activeSegment = getActiveSegment({\n                    segmentsIndexes,\n                    selectionStart,\n                });\n                if (!activeSegment) {\n                    return;\n                }\n                const updatedValue = updateSegmentValue({\n                    selection: segmentsIndexes.get(activeSegment),\n                    value: element.value,\n                    toAdd: event.key === 'ArrowUp' ? step : -step,\n                    max: timeSegmentMaxValues[activeSegment],\n                });\n                maskitoUpdateElement(element, {\n                    value: updatedValue,\n                    selection: [selectionStart, selectionStart],\n                });\n            };\n            element.addEventListener('keydown', listener);\n            return () => element.removeEventListener('keydown', listener);\n        };\n}\nfunction createTimeSegmentsIndexes(fullMode) {\n    return new Map([\n        ['hours', getSegmentRange(fullMode, 'HH')],\n        ['milliseconds', getSegmentRange(fullMode, 'MSS')],\n        ['minutes', getSegmentRange(fullMode, 'MM')],\n        ['seconds', getSegmentRange(fullMode, 'SS')],\n    ]);\n}\nfunction getSegmentRange(mode, segment) {\n    const index = mode.indexOf(segment);\n    return index === -1 ? [-1, -1] : [index, index + segment.length];\n}\nfunction getActiveSegment({ segmentsIndexes, selectionStart, }) {\n    for (const [segmentName, segmentRange] of segmentsIndexes.entries()) {\n        const [from, to] = segmentRange;\n        if (from <= selectionStart && selectionStart <= to) {\n            return segmentName;\n        }\n    }\n    return null;\n}\nfunction updateSegmentValue({ selection, value, toAdd, max, }) {\n    const [from, to] = selection;\n    const segmentValue = Number(value.slice(from, to).padEnd(to - from, '0'));\n    const newSegmentValue = mod(segmentValue + toAdd, max + 1);\n    return (value.slice(0, from) +\n        String(newSegmentValue).padStart(to - from, '0') +\n        value.slice(to, value.length));\n}\nfunction mod(value, max) {\n    if (value < 0) {\n        value += Math.floor(Math.abs(value) / max + 1) * max;\n    }\n    return value % max;\n}\n\nfunction maskitoWithPlaceholder(placeholder, focusedOnly = false) {\n    let lastClearValue = '';\n    let action = 'validation';\n    const removePlaceholder = (value) => {\n        for (let i = value.length - 1; i >= lastClearValue.length; i--) {\n            if (value[i] !== placeholder[i]) {\n                return value.slice(0, i + 1);\n            }\n        }\n        return value.slice(0, lastClearValue.length);\n    };\n    const plugins = [maskitoCaretGuard((value) => [0, removePlaceholder(value).length])];\n    let focused = false;\n    if (focusedOnly) {\n        const focus = maskitoEventHandler('focus', (element) => {\n            focused = true;\n            maskitoUpdateElement(element, element.value + placeholder.slice(element.value.length));\n        }, { capture: true });\n        const blur = maskitoEventHandler('blur', (element) => {\n            focused = false;\n            maskitoUpdateElement(element, removePlaceholder(element.value));\n        }, { capture: true });\n        plugins.push(focus, blur);\n    }\n    return {\n        plugins,\n        removePlaceholder,\n        preprocessors: [\n            ({ elementState, data }, actionType) => {\n                action = actionType;\n                const { value, selection } = elementState;\n                return {\n                    elementState: {\n                        selection,\n                        value: removePlaceholder(value),\n                    },\n                    data,\n                };\n            },\n        ],\n        postprocessors: [\n            ({ value, selection }, initialElementState) => {\n                lastClearValue = value;\n                const justPlaceholderRemoval = value +\n                    placeholder.slice(value.length, initialElementState.value.length) ===\n                    initialElementState.value;\n                if (action === 'validation' && justPlaceholderRemoval) {\n                    /**\n                     * If `value` still equals to `initialElementState.value`,\n                     * then it means that value is patched programmatically (from Maskito's plugin or externally).\n                     * In this case, we don't want to mutate value and automatically add/remove placeholder.\n                     * ___\n                     * For example, developer wants to remove manually placeholder (+ do something else with value) on blur.\n                     * Without this condition, placeholder will be unexpectedly added again.\n                     */\n                    return { selection, value: initialElementState.value };\n                }\n                const newValue = focused || !focusedOnly\n                    ? value + placeholder.slice(value.length)\n                    : value;\n                if (newValue === initialElementState.value &&\n                    action === 'deleteBackward') {\n                    const [caretIndex] = initialElementState.selection;\n                    return {\n                        value: newValue,\n                        selection: [caretIndex, caretIndex],\n                    };\n                }\n                return { value: newValue, selection };\n            },\n        ],\n    };\n}\n\nfunction createZeroPlaceholdersPreprocessor(postfix = '') {\n    const isLastChar = (value, [_, to]) => to >= value.length - postfix.length;\n    return ({ elementState }, actionType) => {\n        const { value, selection } = elementState;\n        if (!value || isLastChar(value, selection)) {\n            return { elementState };\n        }\n        const [from, to] = selection;\n        const zeroes = value.slice(from, to).replaceAll(/\\d/g, '0');\n        const newValue = value.slice(0, from) + zeroes + value.slice(to);\n        if (!zeroes.replaceAll(/\\D/g, '')) {\n            return { elementState };\n        }\n        if (actionType === 'validation' || (actionType === 'insert' && from === to)) {\n            return {\n                elementState: { selection, value: newValue },\n            };\n        }\n        return {\n            elementState: {\n                selection: actionType === 'deleteBackward' || actionType === 'insert'\n                    ? [from, from]\n                    : [to, to],\n                value: newValue,\n            },\n        };\n    };\n}\n\nfunction maskitoDateOptionsGenerator({ mode, separator = '.', max, min, }) {\n    const dateModeTemplate = mode.split('/').join(separator);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: Array.from(dateModeTemplate).map((char) => separator.includes(char) ? char : /\\d/), overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: separator,\n            }),\n            createValidDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: separator,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: separator,\n                splitFn: (value) => ({ dateStrings: [value] }),\n                uniteFn: ([dateString = '']) => dateString,\n            }),\n            createMinMaxDatePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                dateSegmentSeparator: separator,\n            }),\n        ] });\n}\n\nfunction maskitoParseDate(value, { mode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE }) {\n    if (value.length < mode.length) {\n        return null;\n    }\n    const dateSegments = parseDateString(value, mode);\n    const parsedDate = segmentsToDate(dateSegments);\n    return clamp(parsedDate, min, max);\n}\n\nconst formatter = Intl.DateTimeFormat('en-US', {\n    month: '2-digit',\n    day: '2-digit',\n    year: 'numeric',\n});\nfunction toDateSegments(date) {\n    return formatter\n        .formatToParts(date)\n        .reduce((acc, part) => (Object.assign(Object.assign({}, acc), { [part.type]: part.value })), {});\n}\n\nfunction maskitoStringifyDate(date, { mode, separator = '.', min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, }) {\n    const validatedDate = clamp(date, min, max);\n    const segments = toDateSegments(validatedDate);\n    return toDateString(segments, {\n        dateMode: mode.replaceAll('/', separator),\n    });\n}\n\nfunction createMinMaxRangeLengthPostprocessor({ dateModeTemplate, rangeSeparator, minLength, maxLength, max = DEFAULT_MAX_DATE, }) {\n    if (isEmpty(minLength) && isEmpty(maxLength)) {\n        return identity;\n    }\n    return ({ value, selection }) => {\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        if (dateStrings.length !== 2 ||\n            dateStrings.some((date) => !isDateStringComplete(date, dateModeTemplate))) {\n            return { value, selection };\n        }\n        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n        if (!fromDate || !toDate) {\n            return { value, selection };\n        }\n        const minDistantToDate = appendDate(fromDate, minLength);\n        const maxDistantToDate = !isEmpty(maxLength)\n            ? appendDate(fromDate, maxLength)\n            : max;\n        const minLengthClampedToDate = clamp(toDate, minDistantToDate, max);\n        const minMaxLengthClampedToDate = minLengthClampedToDate > maxDistantToDate\n            ? maxDistantToDate\n            : minLengthClampedToDate;\n        return {\n            selection,\n            value: dateStrings[0] +\n                rangeSeparator +\n                toDateString(dateToSegments(minMaxLengthClampedToDate), {\n                    dateMode: dateModeTemplate,\n                }),\n        };\n    };\n}\n\nfunction createSwapDatesPostprocessor({ dateModeTemplate, rangeSeparator, }) {\n    return ({ value, selection }) => {\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        const isDateRangeComplete = dateStrings.length === 2 &&\n            dateStrings.every((date) => isDateStringComplete(date, dateModeTemplate));\n        const [from, to] = selection;\n        const caretAtTheEnd = from >= value.length;\n        const allValueSelected = from === 0 && to >= value.length; // dropping text inside with a pointer\n        if (!(caretAtTheEnd || allValueSelected) || !isDateRangeComplete) {\n            return { value, selection };\n        }\n        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n        return {\n            selection,\n            value: fromDate && toDate && fromDate > toDate\n                ? dateStrings.reverse().join(rangeSeparator)\n                : value,\n        };\n    };\n}\n\nfunction maskitoDateRangeOptionsGenerator({ mode, min, max, minLength, maxLength, dateSeparator = '.', rangeSeparator = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`, }) {\n    const dateModeTemplate = mode.split('/').join(dateSeparator);\n    const dateMask = Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\\d/);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [...dateMask, ...Array.from(rangeSeparator), ...dateMask], overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createFirstDateEndSeparatorPreprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                firstDateEndSeparator: rangeSeparator,\n                pseudoFirstDateEndSeparators: POSSIBLE_DATE_RANGE_SEPARATOR,\n            }),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentsSeparator: dateSeparator,\n            }),\n            createValidDatePreprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentsSeparator: dateSeparator,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                splitFn: (value) => ({\n                    dateStrings: parseDateRangeString(value, dateModeTemplate, rangeSeparator),\n                }),\n                uniteFn: (validatedDateStrings, initialValue) => validatedDateStrings.reduce((acc, dateString, dateIndex) => acc +\n                    dateString +\n                    (!dateIndex && initialValue.includes(rangeSeparator)\n                        ? rangeSeparator\n                        : ''), ''),\n            }),\n            createMinMaxDatePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentSeparator: dateSeparator,\n            }),\n            createMinMaxRangeLengthPostprocessor({\n                dateModeTemplate,\n                minLength,\n                maxLength,\n                max,\n                rangeSeparator,\n            }),\n            createSwapDatesPostprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n            }),\n        ] });\n}\n\nfunction isDateTimeStringComplete(dateTimeString, { dateMode, timeMode, dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    var _a;\n    return (dateTimeString.length >=\n        dateMode.length + timeMode.length + dateTimeSeparator.length &&\n        ((_a = dateTimeString.split(dateTimeSeparator)[0]) !== null && _a !== void 0 ? _a : '')\n            .split(/\\D/)\n            .every((segment) => !/^0+$/.exec(segment)));\n}\n\nfunction maskitoTimeOptionsGenerator({ mode, timeSegmentMaxValues = {}, timeSegmentMinValues = {}, step = 0, prefix = '', postfix = '', }) {\n    const hasMeridiem = mode.includes('AA');\n    const enrichedTimeSegmentMaxValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), (hasMeridiem ? { hours: 12 } : {})), timeSegmentMaxValues);\n    const enrichedTimeSegmentMinValues = Object.assign(Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), (hasMeridiem ? { hours: 1 } : {})), timeSegmentMinValues);\n    const maskExpression = [...prefix, ...createTimeMaskExpression(mode)];\n    return {\n        mask: postfix\n            ? ({ value }) => cutExpression(maskExpression, value).concat(...postfix)\n            : maskExpression,\n        preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createColonConvertPreprocessor(),\n            createZeroPlaceholdersPreprocessor(postfix),\n            createMeridiemPreprocessor(mode),\n            createInvalidTimeSegmentInsertionPreprocessor({\n                timeMode: mode,\n                timeSegmentMinValues: enrichedTimeSegmentMinValues,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n        ],\n        postprocessors: [\n            createMeridiemPostprocessor(mode),\n            (elementState) => enrichTimeSegmentsWithZeroes(elementState, {\n                mode,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n            maskitoPrefixPostprocessorGenerator(prefix),\n            maskitoPostfixPostprocessorGenerator(postfix),\n        ],\n        plugins: [\n            createTimeSegmentsSteppingPlugin({\n                fullMode: mode,\n                step,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n            createMeridiemSteppingPlugin(mode.indexOf('AA')),\n        ],\n        overwriteMode: 'replace',\n    };\n}\n/**\n * Without cutting, the mask expression removes postfix on the last digit deletion\n * ___\n * Case 1 (static pattern mask expression)\n * Mask expression is [/\\d/, /\\d/, ':', /\\d/, /\\d/, ' left']\n * 12:34| left => Press Backspace => 12:3|\n * Mask correctly removes postfix because it's fixed characters after not yet inserted 4th digit.\n * ___\n * Case 2 (dynamic pattern mask expression)\n * Mask expression is [/\\d/, /\\d/, ':', /\\d/, /\\d/, ' left'] & textfield contains `12:34 left`\n * 12:34| left => Press Backspace => Mask expression becomes [/\\d/, /\\d/, ':', /\\d/, ' left']  => 12:3| left\n * Mask correctly does not remove postfix because it's trailing fixed characters\n * and all non-fixed characters were already inserted.\n */\nfunction cutExpression(expression, value) {\n    let digitsCount = Math.min(value.replaceAll(/\\D/g, '').length, expression.filter((x) => typeof x !== 'string').length) || 1;\n    const afterLastDigit = expression.findIndex((x) => typeof x !== 'string' && !--digitsCount) + 1;\n    return expression.slice(0, afterLastDigit);\n}\n\n/**\n * Converts a formatted time string to milliseconds based on the given `options.mode`.\n *\n * @param maskedTime a formatted time string by {@link maskitoTimeOptionsGenerator} or {@link maskitoStringifyTime}\n * @param params\n */\nfunction maskitoParseTime(maskedTime, { mode, timeSegmentMaxValues = {} }) {\n    var _a, _b, _c, _d;\n    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    const msInSecond = maxValues.milliseconds + 1;\n    const msInMinute = (maxValues.seconds + 1) * msInSecond;\n    const msInHour = (maxValues.minutes + 1) * msInMinute;\n    const parsedTime = padEndTimeSegments(parseTimeString(maskedTime, mode));\n    return (Number((_a = parsedTime.hours) !== null && _a !== void 0 ? _a : '') * msInHour +\n        Number((_b = parsedTime.minutes) !== null && _b !== void 0 ? _b : '') * msInMinute +\n        Number((_c = parsedTime.seconds) !== null && _c !== void 0 ? _c : '') * msInSecond +\n        Number((_d = parsedTime.milliseconds) !== null && _d !== void 0 ? _d : ''));\n}\n\n/**\n * Converts milliseconds to a formatted time string based on the given `options.mode`.\n *\n * @param milliseconds unsigned integer milliseconds\n * @param params\n */\nfunction maskitoStringifyTime(milliseconds, { mode, timeSegmentMaxValues = {} }) {\n    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    const msInSecond = maxValues.milliseconds + 1;\n    const msInMinute = (maxValues.seconds + 1) * msInSecond;\n    const msInHour = (maxValues.minutes + 1) * msInMinute;\n    const hours = Math.trunc(milliseconds / msInHour);\n    milliseconds -= hours * msInHour;\n    const minutes = Math.trunc(milliseconds / msInMinute);\n    milliseconds -= minutes * msInMinute;\n    const seconds = Math.trunc(milliseconds / msInSecond);\n    milliseconds -= seconds * msInSecond;\n    const result = padStartTimeSegments({ hours, minutes, seconds, milliseconds });\n    return mode\n        .replaceAll(/H+/g, result.hours)\n        .replaceAll('MSS', result.milliseconds)\n        .replaceAll(/M+/g, result.minutes)\n        .replaceAll(/S+/g, result.seconds);\n}\n\nfunction maskitoParseDateTime(value, { dateMode, timeMode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    const [dateSegment = '', timeSegment = ''] = value.split(dateTimeSeparator);\n    if (timeSegment.length !== timeMode.length) {\n        return null;\n    }\n    const date = maskitoParseDate(dateSegment, { mode: dateMode });\n    const time = maskitoParseTime(timeSegment, { mode: timeMode });\n    if (!date) {\n        return null;\n    }\n    const dateTime = new Date(Number(date) + time);\n    return clamp(dateTime, min, max);\n}\n\nconst NON_DIGIT_PLACEHOLDER_RE = /[^dmy]/g;\nconst LEADING_NON_DIGIT_RE = /^\\D*/;\nfunction splitDateTimeString(dateTime, dateModeTemplate) {\n    const dateDigitsCount = dateModeTemplate.replaceAll(NON_DIGIT_PLACEHOLDER_RE, '').length;\n    const [date = ''] = new RegExp(`(\\\\d[^\\\\d]*){0,${dateDigitsCount - 1}}\\\\d?`).exec(dateTime) || [];\n    const [dateTimeSeparator = ''] = LEADING_NON_DIGIT_RE.exec(dateTime.slice(date.length)) || [];\n    return [date, dateTime.slice(date.length + dateTimeSeparator.length)];\n}\n\nfunction maskitoStringifyDateTime(date, { dateMode, timeMode, dateTimeSeparator = DATE_TIME_SEPARATOR, dateSeparator = '.', min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, }) {\n    const validatedDate = clamp(date, min, max);\n    const dateString = maskitoStringifyDate(validatedDate, {\n        mode: dateMode,\n        separator: dateSeparator,\n        min,\n        max,\n    });\n    const extractedTime = Number(validatedDate) -\n        Number(new Date(validatedDate.getFullYear(), validatedDate.getMonth(), validatedDate.getDate()));\n    const timeString = maskitoStringifyTime(extractedTime, { mode: timeMode });\n    return dateString + dateTimeSeparator + timeString;\n}\n\nfunction createMinMaxDateTimePostprocessor({ dateModeTemplate, timeMode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, dateTimeSeparator, }) {\n    return ({ value, selection }) => {\n        const [dateString, timeString] = splitDateTimeString(value, dateModeTemplate);\n        const parsedDate = parseDateString(dateString, dateModeTemplate);\n        const parsedTime = parseTimeString(timeString, timeMode);\n        if (!isDateTimeStringComplete(value, {\n            dateMode: dateModeTemplate,\n            timeMode,\n            dateTimeSeparator,\n        })) {\n            const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n            const { year, month, day } = isDateStringComplete(dateString, dateModeTemplate)\n                ? dateToSegments(clamp(segmentsToDate(fixedDate), min, max))\n                : fixedDate;\n            const fixedValue = toDateString(Object.assign({ year,\n                month,\n                day }, parsedTime), { dateMode: dateModeTemplate, dateTimeSeparator, timeMode });\n            const tail = value.slice(fixedValue.length);\n            return {\n                selection,\n                value: fixedValue + tail,\n            };\n        }\n        const date = segmentsToDate(parsedDate, parsedTime);\n        const clampedDate = clamp(date, min, max);\n        // trailing segment separators or meridiem characters\n        const [trailingNonDigitCharacters = ''] = value.match(/\\D+$/g) || [];\n        const validatedValue = toDateString(dateToSegments(clampedDate), {\n            dateMode: dateModeTemplate,\n            dateTimeSeparator,\n            timeMode,\n        }) + trailingNonDigitCharacters;\n        return {\n            selection,\n            value: validatedValue,\n        };\n    };\n}\n\nfunction createValidDateTimePreprocessor({ dateModeTemplate, dateSegmentsSeparator, dateTimeSeparator, timeMode, timeSegmentMaxValues, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        if (data === dateSegmentsSeparator) {\n            return {\n                elementState,\n                data: selection[0] === value.length ? data : '',\n            };\n        }\n        const newCharacters = data.replaceAll(/\\D/g, '');\n        if (!newCharacters) {\n            return { elementState, data };\n        }\n        const [from, rawTo] = selection;\n        let to = rawTo + data.length;\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const [dateString, timeString] = splitDateTimeString(newPossibleValue, dateModeTemplate);\n        let validatedValue = '';\n        const hasDateTimeSeparator = newPossibleValue.includes(dateTimeSeparator);\n        const { validatedDateString, updatedSelection } = validateDateString({\n            dateString,\n            dateSegmentsSeparator,\n            dateModeTemplate,\n            offset: 0,\n            selection: [from, to],\n        });\n        if (dateString && !validatedDateString) {\n            return { elementState, data: '' }; // prevent changes\n        }\n        to = updatedSelection[1];\n        validatedValue += validatedDateString;\n        const updatedTimeState = enrichTimeSegmentsWithZeroes({ value: timeString, selection: [from, to] }, { mode: timeMode, timeSegmentMaxValues });\n        to = updatedTimeState.selection[1];\n        validatedValue += hasDateTimeSeparator\n            ? dateTimeSeparator + updatedTimeState.value\n            : updatedTimeState.value;\n        const newData = validatedValue.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedValue.slice(0, from) +\n                    newData\n                        .split(dateSegmentsSeparator)\n                        .map((segment) => '0'.repeat(segment.length))\n                        .join(dateSegmentsSeparator) +\n                    validatedValue.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoDateTimeOptionsGenerator({ dateMode, timeMode, dateSeparator = '.', min, max, dateTimeSeparator = DATE_TIME_SEPARATOR, timeStep = 0, }) {\n    const hasMeridiem = timeMode.includes('AA');\n    const dateModeTemplate = dateMode.split('/').join(dateSeparator);\n    const timeSegmentMaxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), (hasMeridiem ? { hours: 12 } : {}));\n    const timeSegmentMinValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MIN_VALUES), (hasMeridiem ? { hours: 1 } : {}));\n    const fullMode = `${dateModeTemplate}${dateTimeSeparator}${timeMode}`;\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [\n            ...Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\\d/),\n            ...dateTimeSeparator.split(''),\n            ...createTimeMaskExpression(timeMode),\n        ], overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createColonConvertPreprocessor(),\n            createFirstDateEndSeparatorPreprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                firstDateEndSeparator: dateTimeSeparator,\n                pseudoFirstDateEndSeparators: dateTimeSeparator.split(''),\n            }),\n            createZeroPlaceholdersPreprocessor(),\n            createMeridiemPreprocessor(timeMode),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: dateSeparator,\n                dateTimeSeparator,\n            }),\n            createInvalidTimeSegmentInsertionPreprocessor({\n                timeMode,\n                timeSegmentMinValues,\n                timeSegmentMaxValues,\n                parseValue: (x) => {\n                    const [dateString, timeString] = splitDateTimeString(x, dateModeTemplate);\n                    return { timeString, restValue: dateString + dateTimeSeparator };\n                },\n            }),\n            createValidDateTimePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: dateSeparator,\n                dateTimeSeparator,\n                timeMode,\n                timeSegmentMaxValues,\n            }),\n        ], postprocessors: [\n            createMeridiemPostprocessor(timeMode),\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                splitFn: (value) => {\n                    const [dateString, timeString] = splitDateTimeString(value, dateModeTemplate);\n                    return { dateStrings: [dateString], restPart: timeString };\n                },\n                uniteFn: ([validatedDateString], initialValue) => validatedDateString +\n                    (initialValue.includes(dateTimeSeparator) ? dateTimeSeparator : ''),\n            }),\n            createMinMaxDateTimePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                timeMode,\n                dateTimeSeparator,\n            }),\n        ], plugins: [\n            createTimeSegmentsSteppingPlugin({\n                step: timeStep,\n                fullMode,\n                timeSegmentMaxValues: DEFAULT_TIME_SEGMENT_MAX_VALUES,\n            }),\n            createMeridiemSteppingPlugin(fullMode.indexOf('AA')),\n        ] });\n}\n\n/**\n * It drops prefix and postfix from data\n * Needed for case, when prefix or postfix contain decimalSeparator, to ignore it in resulting number\n * @example User pastes '{prefix}123.45{postfix}' => 123.45\n */\nfunction createAffixesFilterPreprocessor({ prefix, postfix, }) {\n    return ({ elementState, data }) => {\n        const { cleanValue: cleanData } = extractAffixes(data, {\n            prefix,\n            postfix,\n        });\n        return {\n            elementState,\n            data: cleanData,\n        };\n    };\n}\n\nfunction generateMaskExpression({ decimalPseudoSeparators, decimalSeparator, maximumFractionDigits, min, minusSign, postfix, prefix, pseudoMinuses, thousandSeparator, }) {\n    const computedPrefix = min < 0 && [minusSign, ...pseudoMinuses].includes(prefix)\n        ? ''\n        : computeAllOptionalCharsRegExp(prefix);\n    const digit = String.raw `\\d`;\n    const optionalMinus = min < 0 ? `[${minusSign}${pseudoMinuses.map((x) => `\\\\${x}`).join('')}]?` : '';\n    const integerPart = thousandSeparator\n        ? `[${digit}${escapeRegExp(thousandSeparator).replaceAll(/\\s/g, String.raw `\\s`)}]*`\n        : `[${digit}]*`;\n    const precisionPart = Number.isFinite(maximumFractionDigits)\n        ? maximumFractionDigits\n        : '';\n    const decimalPart = maximumFractionDigits > 0\n        ? `([${escapeRegExp(decimalSeparator)}${decimalPseudoSeparators\n            .map(escapeRegExp)\n            .join('')}]${digit}{0,${precisionPart}})?`\n        : '';\n    const computedPostfix = computeAllOptionalCharsRegExp(postfix);\n    return new RegExp(`^${computedPrefix}${optionalMinus}${integerPart}${decimalPart}${computedPostfix}$`);\n}\nfunction computeAllOptionalCharsRegExp(str) {\n    return str\n        ? `${str\n            .split('')\n            .map((char) => `${escapeRegExp(char)}?`)\n            .join('')}`\n        : '';\n}\n\nfunction maskitoParseNumber(maskedNumber, \n// TODO(v4): decimalSeparatorOrParams: MaskitoNumberParams | string => params: MaskitoNumberParams = {}\ndecimalSeparatorOrParams = {}) {\n    const { decimalSeparator = '.', minusSign = '' } = typeof decimalSeparatorOrParams === 'string'\n        ? { decimalSeparator: decimalSeparatorOrParams }\n        : decimalSeparatorOrParams;\n    const hasNegativeSign = !!new RegExp(`^\\\\D*[${escapeRegExp(minusSign)}\\\\${DEFAULT_PSEUDO_MINUSES.join('\\\\')}]`).exec(maskedNumber);\n    const escapedDecimalSeparator = escapeRegExp(decimalSeparator);\n    const unmaskedNumber = maskedNumber\n        // drop all decimal separators not followed by a digit\n        .replaceAll(new RegExp(`${escapedDecimalSeparator}(?!\\\\d)`, 'g'), '')\n        // drop all non-digit characters except decimal separator\n        .replaceAll(new RegExp(`[^\\\\d${escapedDecimalSeparator}]`, 'g'), '')\n        .replace(decimalSeparator, decimalSeparator && '.');\n    if (unmaskedNumber) {\n        const sign = hasNegativeSign ? CHAR_HYPHEN : '';\n        return Number(`${sign}${unmaskedNumber}`);\n    }\n    return NaN;\n}\n\n/**\n * Convert number to string with replacing exponent part on decimals\n *\n * @param value the number\n * @return string representation of a number\n */\nfunction stringifyNumberWithoutExp(value) {\n    var _a;\n    const valueAsString = String(value);\n    const [numberPart = '', expPart] = valueAsString.split('e-');\n    let valueWithoutExp = valueAsString;\n    if (expPart) {\n        const [, fractionalPart] = numberPart.split('.');\n        const decimalDigits = Number(expPart) + ((_a = fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) !== null && _a !== void 0 ? _a : 0);\n        valueWithoutExp = value.toFixed(decimalDigits);\n    }\n    return valueWithoutExp;\n}\n\nfunction maskitoStringifyNumber(number, params) {\n    if (Number.isNaN(number) || number === null) {\n        return '';\n    }\n    const { min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, decimalSeparator = '.', } = params;\n    const value = stringifyNumberWithoutExp(clamp(number, min, max)).replace('.', decimalSeparator);\n    return maskitoTransform(value, maskitoNumberOptionsGenerator(params));\n}\n\nfunction toNumberParts(value, { decimalSeparator, minusSign }) {\n    const [integerWithMinus = '', decimalPart = ''] = decimalSeparator\n        ? value.split(decimalSeparator)\n        : [value];\n    const escapedMinus = escapeRegExp(minusSign);\n    const [, minus = '', integerPart = ''] = new RegExp(`^(?:[^\\\\d${escapedMinus}])?(${escapedMinus})?(.*)`).exec(integerWithMinus) || [];\n    return { minus, integerPart, decimalPart };\n}\n\nfunction validateDecimalPseudoSeparators({ decimalSeparator, thousandSeparator, decimalPseudoSeparators = DEFAULT_DECIMAL_PSEUDO_SEPARATORS, }) {\n    return decimalPseudoSeparators.filter((char) => char !== thousandSeparator && char !== decimalSeparator);\n}\n\n/**\n * If `minimumFractionDigits` is `>0`, it pads decimal part with zeroes\n * (until number of digits after decimalSeparator is equal to the `minimumFractionDigits`).\n * @example 1,42 => (`minimumFractionDigits` is equal to 4) => 1,4200.\n */\nfunction createDecimalZeroPaddingPostprocessor({ decimalSeparator, minimumFractionDigits, prefix, postfix, minusSign, }) {\n    if (!minimumFractionDigits) {\n        return identity;\n    }\n    return ({ value, selection }) => {\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        if (Number.isNaN(maskitoParseNumber(cleanValue, { decimalSeparator, minusSign }))) {\n            return { value, selection };\n        }\n        const [integerPart, decimalPart = ''] = cleanValue.split(decimalSeparator);\n        return {\n            value: extractedPrefix +\n                integerPart +\n                decimalSeparator +\n                decimalPart.padEnd(minimumFractionDigits, '0') +\n                extractedPostfix,\n            selection,\n        };\n    };\n}\n\n/**\n * Make textfield empty if there is no integer part and all decimal digits are zeroes.\n * @example 0|,00 => Backspace => Empty.\n * @example -0|,00 => Backspace => -.\n * @example ,42| => Backspace x2 => ,|00 => Backspace => Empty\n */\nfunction emptyPostprocessor({ prefix, postfix, decimalSeparator, minusSign, }) {\n    return ({ value, selection }) => {\n        const [caretIndex] = selection;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const { minus, integerPart, decimalPart } = toNumberParts(cleanValue, {\n            decimalSeparator,\n            minusSign,\n        });\n        const aloneDecimalSeparator = !integerPart &&\n            !decimalPart &&\n            Boolean(decimalSeparator) &&\n            cleanValue.includes(decimalSeparator);\n        if ((!integerPart &&\n            !Number(decimalPart) &&\n            caretIndex === (minus + extractedPrefix).length) ||\n            aloneDecimalSeparator) {\n            return {\n                selection,\n                value: extractedPrefix + minus + extractedPostfix,\n            };\n        }\n        return { value, selection };\n    };\n}\n\n/**\n * This preprocessor works only once at initialization phase (when `new Maskito(...)` is executed).\n * This preprocessor helps to avoid conflicts during transition from one mask to another (for the same input).\n * For example, the developer changes postfix (or other mask's props) during run-time.\n * ```\n * let maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' year'});\n * // [3 seconds later]\n * maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' years'});\n * ```\n */\nfunction createInitializationOnlyPreprocessor({ decimalPseudoSeparators, decimalSeparator, minusSign, postfix, prefix, pseudoMinuses, }) {\n    let isInitializationPhase = true;\n    const cleanNumberMask = generateMaskExpression({\n        decimalSeparator,\n        decimalPseudoSeparators,\n        pseudoMinuses,\n        prefix: '',\n        postfix: '',\n        thousandSeparator: '',\n        maximumFractionDigits: Infinity,\n        min: Number.MIN_SAFE_INTEGER,\n        minusSign,\n    });\n    return ({ elementState, data }) => {\n        if (!isInitializationPhase) {\n            return { elementState, data };\n        }\n        isInitializationPhase = false;\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const { extractedPrefix, cleanValue, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const cleanState = maskitoTransform({\n            selection: [\n                Math.max(from - extractedPrefix.length, 0),\n                clamp(to - extractedPrefix.length, 0, cleanValue.length),\n            ],\n            value: cleanValue,\n        }, {\n            mask: cleanNumberMask,\n        });\n        const [cleanFrom, cleanTo] = cleanState.selection;\n        return {\n            elementState: {\n                selection: [\n                    cleanFrom + extractedPrefix.length,\n                    cleanTo + extractedPrefix.length,\n                ],\n                value: extractedPrefix + cleanState.value + extractedPostfix,\n            },\n            data,\n        };\n    };\n}\n\n/**\n * It removes repeated leading zeroes for integer part.\n * @example 0,|00005 => Backspace => |5\n * @example -0,|00005 => Backspace => -|5\n * @example User types \"000000\" => 0|\n * @example 0| => User types \"5\" => 5|\n */\nfunction createLeadingZeroesValidationPostprocessor({ decimalSeparator, thousandSeparator, prefix, postfix, }) {\n    const trimLeadingZeroes = (value) => {\n        const escapedThousandSeparator = escapeRegExp(thousandSeparator);\n        return value\n            .replace(\n        // all leading zeroes followed by another zero\n        new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=0)`), '$1')\n            .replace(\n        // zero followed by not-zero digit\n        new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=[1-9])`), '$1');\n    };\n    const countTrimmedZeroesBefore = (value, index) => {\n        const valueBefore = value.slice(0, index);\n        const followedByZero = value.slice(index).startsWith('0');\n        return (valueBefore.length -\n            trimLeadingZeroes(valueBefore).length +\n            (followedByZero ? 1 : 0));\n    };\n    return ({ value, selection }) => {\n        const [from, to] = selection;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const hasDecimalSeparator = Boolean(decimalSeparator) && cleanValue.includes(decimalSeparator);\n        const [integerPart = '', decimalPart = ''] = decimalSeparator\n            ? cleanValue.split(decimalSeparator)\n            : [cleanValue];\n        const zeroTrimmedIntegerPart = trimLeadingZeroes(integerPart);\n        if (integerPart === zeroTrimmedIntegerPart) {\n            return { value, selection };\n        }\n        const newFrom = from - countTrimmedZeroesBefore(value, from);\n        const newTo = to - countTrimmedZeroesBefore(value, to);\n        return {\n            value: extractedPrefix +\n                zeroTrimmedIntegerPart +\n                (hasDecimalSeparator ? decimalSeparator : '') +\n                decimalPart +\n                extractedPostfix,\n            selection: [Math.max(newFrom, 0), Math.max(newTo, 0)],\n        };\n    };\n}\n\n/**\n * This postprocessor is connected with {@link createMinMaxPlugin}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPostprocessor({ min, max, decimalSeparator, minusSign, }) {\n    return ({ value, selection }) => {\n        const parsedNumber = maskitoParseNumber(value, { decimalSeparator, minusSign });\n        const limitedValue = \n        /**\n         * We cannot limit lower bound if user enters positive number.\n         * The same for upper bound and negative number.\n         * ___\n         * @example (min = 5)\n         * Empty input => Without this condition user cannot type 42 (the first digit will be rejected)\n         * ___\n         * @example (max = -10)\n         * Value is -10 => Without this condition user cannot delete 0 to enter another digit\n         */\n        parsedNumber > 0 ? Math.min(parsedNumber, max) : Math.max(parsedNumber, min);\n        if (parsedNumber && limitedValue !== parsedNumber) {\n            const newValue = `${limitedValue}`\n                .replace('.', decimalSeparator)\n                .replace(CHAR_HYPHEN, minusSign);\n            return {\n                value: newValue,\n                selection: [newValue.length, newValue.length],\n            };\n        }\n        return {\n            value,\n            selection,\n        };\n    };\n}\n\n/**\n * Manage caret-navigation when user \"deletes\" non-removable digits or separators\n * @example 1,|42 => Backspace => 1|,42 (only if `minimumFractionDigits` is `>0`)\n * @example 1|,42 => Delete => 1,|42 (only if `minimumFractionDigits` is `>0`)\n * @example 0,|00 => Delete => 0,0|0 (only if `minimumFractionDigits` is `>0`)\n * @example 1 |000 => Backspace => 1| 000 (always)\n */\nfunction createNonRemovableCharsDeletionPreprocessor({ decimalSeparator, thousandSeparator, minimumFractionDigits, }) {\n    return ({ elementState, data }, actionType) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const selectedCharacters = value.slice(from, to);\n        const nonRemovableSeparators = minimumFractionDigits\n            ? [decimalSeparator, thousandSeparator]\n            : [thousandSeparator];\n        const areNonRemovableZeroesSelected = Boolean(minimumFractionDigits) &&\n            from > value.indexOf(decimalSeparator) &&\n            Boolean(selectedCharacters.match(/^0+$/gi));\n        if ((actionType !== 'deleteBackward' && actionType !== 'deleteForward') ||\n            (!nonRemovableSeparators.includes(selectedCharacters) &&\n                !areNonRemovableZeroesSelected)) {\n            return {\n                elementState,\n                data,\n            };\n        }\n        return {\n            elementState: {\n                value,\n                selection: actionType === 'deleteForward' ? [to, to] : [from, from],\n            },\n            data,\n        };\n    };\n}\n\n/**\n * It pads integer part with zero if user types decimal separator (for empty input).\n * @example Empty input => User types \",\" (decimal separator) => 0,|\n */\nfunction createNotEmptyIntegerPartPreprocessor({ decimalSeparator, maximumFractionDigits, prefix, postfix, }) {\n    const startWithDecimalSepRegExp = new RegExp(`^\\\\D*${escapeRegExp(decimalSeparator)}`);\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const [from, to] = selection;\n        const cleanFrom = clamp(from - extractedPrefix.length, 0, cleanValue.length);\n        const cleanTo = clamp(to - extractedPrefix.length, 0, cleanValue.length);\n        if (maximumFractionDigits <= 0 ||\n            cleanValue.slice(0, cleanFrom).includes(decimalSeparator) ||\n            cleanValue.slice(cleanTo).includes(decimalSeparator) ||\n            !data.match(startWithDecimalSepRegExp)) {\n            return { elementState, data };\n        }\n        const digitsBeforeCursor = /\\d+/.exec(cleanValue.slice(0, cleanFrom));\n        return {\n            elementState,\n            data: digitsBeforeCursor ? data : `0${data}`,\n        };\n    };\n}\n\n/**\n * It replaces pseudo characters with valid one.\n * @example User types '.' (but separator is equal to comma) => dot is replaced with comma.\n * @example User types hyphen / en-dash / em-dash => it is replaced with minus.\n */\nfunction createPseudoCharactersPreprocessor({ validCharacter, pseudoCharacters, prefix, postfix, }) {\n    const pseudoCharactersRegExp = new RegExp(`[${pseudoCharacters.join('')}]`, 'gi');\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        return {\n            elementState: {\n                selection,\n                value: extractedPrefix +\n                    cleanValue.replace(pseudoCharactersRegExp, validCharacter) +\n                    extractedPostfix,\n            },\n            data: data.replace(pseudoCharactersRegExp, validCharacter),\n        };\n    };\n}\n\n/**\n * It rejects new typed decimal separator if it already exists in text field.\n * Behaviour is similar to native <input type=\"number\"> (Chrome).\n * @example 1|23,45 => Press comma (decimal separator) => 1|23,45 (do nothing).\n */\nfunction createRepeatedDecimalSeparatorPreprocessor({ decimalSeparator, prefix, postfix, }) {\n    if (!decimalSeparator) {\n        return identity;\n    }\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const { cleanValue } = extractAffixes(value, { prefix, postfix });\n        return {\n            elementState,\n            data: !cleanValue.includes(decimalSeparator) ||\n                value.slice(from, to + 1).includes(decimalSeparator)\n                ? data\n                : data.replaceAll(new RegExp(escapeRegExp(decimalSeparator), 'gi'), ''),\n        };\n    };\n}\n\n/**\n * It adds symbol for separating thousands.\n * @example 1000000 => (thousandSeparator is equal to space) => 1 000 000.\n */\nfunction createThousandSeparatorPostprocessor({ thousandSeparator, decimalSeparator, prefix, postfix, minusSign, }) {\n    if (!thousandSeparator) {\n        return identity;\n    }\n    const isAllSpaces = (...chars) => chars.every((x) => /\\s/.test(x));\n    return ({ value, selection }) => {\n        const [initialFrom, initialTo] = selection;\n        let [from, to] = selection;\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const { minus, integerPart, decimalPart } = toNumberParts(cleanValue, {\n            decimalSeparator,\n            minusSign,\n        });\n        const hasDecimalSeparator = decimalSeparator && cleanValue.includes(decimalSeparator);\n        const deletedChars = cleanValue.length -\n            (minus +\n                integerPart +\n                (hasDecimalSeparator ? decimalSeparator + decimalPart : '')).length;\n        if (deletedChars > 0 && initialFrom && initialFrom <= deletedChars) {\n            from -= deletedChars;\n        }\n        if (deletedChars > 0 && initialTo && initialTo <= deletedChars) {\n            to -= deletedChars;\n        }\n        const processedIntegerPart = Array.from(integerPart).reduceRight((formattedValuePart, char, i) => {\n            const isLeadingThousandSeparator = !i && char === thousandSeparator;\n            const isPositionForSeparator = !isLeadingThousandSeparator &&\n                Boolean(formattedValuePart.length) &&\n                (formattedValuePart.length + 1) % 4 === 0;\n            const isSeparator = char === thousandSeparator || isAllSpaces(char, thousandSeparator);\n            if (isPositionForSeparator && isSeparator) {\n                return thousandSeparator + formattedValuePart;\n            }\n            if (!isPositionForSeparator && isSeparator) {\n                if (i && i <= initialFrom) {\n                    from--;\n                }\n                if (i && i <= initialTo) {\n                    to--;\n                }\n                return formattedValuePart;\n            }\n            if (!isPositionForSeparator) {\n                return char + formattedValuePart;\n            }\n            if (i < initialFrom) {\n                from++;\n            }\n            if (i < initialTo) {\n                to++;\n            }\n            return char + thousandSeparator + formattedValuePart;\n        }, '');\n        return {\n            value: extractedPrefix +\n                minus +\n                processedIntegerPart +\n                (hasDecimalSeparator ? decimalSeparator : '') +\n                decimalPart +\n                extractedPostfix,\n            selection: [from, to],\n        };\n    };\n}\n\n/**\n * It drops decimal part if `maximumFractionDigits` is zero.\n * @example User pastes '123.45' (but `maximumFractionDigits` is zero) => 123\n */\nfunction createZeroPrecisionPreprocessor({ maximumFractionDigits, decimalSeparator, prefix, postfix, }) {\n    if (maximumFractionDigits > 0 ||\n        !decimalSeparator // all separators should be treated only as thousand separators\n    ) {\n        return identity;\n    }\n    const decimalPartRegExp = new RegExp(`${escapeRegExp(decimalSeparator)}.*$`, 'g');\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const [from, to] = selection;\n        const newValue = extractedPrefix +\n            cleanValue.replace(decimalPartRegExp, '') +\n            extractedPostfix;\n        return {\n            elementState: {\n                selection: [\n                    Math.min(from, newValue.length),\n                    Math.min(to, newValue.length),\n                ],\n                value: newValue,\n            },\n            data: data.replace(decimalPartRegExp, ''),\n        };\n    };\n}\n\nconst DUMMY_SELECTION = [0, 0];\n/**\n * It removes repeated leading zeroes for integer part on blur-event.\n * @example 000000 => blur => 0\n * @example 00005 => blur => 5\n */\nfunction createLeadingZeroesValidationPlugin({ decimalSeparator, thousandSeparator, prefix, postfix, }) {\n    const dropRepeatedLeadingZeroes = createLeadingZeroesValidationPostprocessor({\n        decimalSeparator,\n        thousandSeparator,\n        prefix,\n        postfix,\n    });\n    return maskitoEventHandler('blur', (element) => {\n        const newValue = dropRepeatedLeadingZeroes({\n            value: element.value,\n            selection: DUMMY_SELECTION,\n        }, { value: '', selection: DUMMY_SELECTION }).value;\n        maskitoUpdateElement(element, newValue);\n    }, { capture: true });\n}\n\n/**\n * This plugin is connected with {@link createMinMaxPostprocessor}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPlugin({ min, max, decimalSeparator, minusSign, }) {\n    return maskitoEventHandler('blur', (element, options) => {\n        const parsedNumber = maskitoParseNumber(element.value, {\n            decimalSeparator,\n            minusSign,\n        });\n        const clampedNumber = clamp(parsedNumber, min, max);\n        if (!Number.isNaN(parsedNumber) && parsedNumber !== clampedNumber) {\n            maskitoUpdateElement(element, maskitoTransform(stringifyNumberWithoutExp(clampedNumber), options));\n        }\n    }, { capture: true });\n}\n\n/**\n * It pads EMPTY integer part with zero if decimal parts exists.\n * It works on blur event only!\n * @example 1|,23 => Backspace => Blur => 0,23\n */\nfunction createNotEmptyIntegerPlugin({ decimalSeparator, prefix, postfix, }) {\n    if (!decimalSeparator) {\n        return noop;\n    }\n    return maskitoEventHandler('blur', (element) => {\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(element.value, { prefix, postfix });\n        const newValue = extractedPrefix +\n            cleanValue.replace(new RegExp(`^(\\\\D+)?${escapeRegExp(decimalSeparator)}`), `$10${decimalSeparator}`) +\n            extractedPostfix;\n        maskitoUpdateElement(element, newValue);\n    }, { capture: true });\n}\n\nconst DEFAULT_PSEUDO_MINUSES = [\n    CHAR_HYPHEN,\n    CHAR_EN_DASH,\n    CHAR_EM_DASH,\n    CHAR_JP_HYPHEN,\n    CHAR_MINUS,\n];\nfunction maskitoNumberOptionsGenerator({ max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, precision = 0, thousandSeparator = CHAR_NO_BREAK_SPACE, decimalSeparator = '.', decimalPseudoSeparators, decimalZeroPadding = false, prefix: unsafePrefix = '', postfix = '', minusSign = CHAR_MINUS, maximumFractionDigits = precision, minimumFractionDigits = decimalZeroPadding ? maximumFractionDigits : 0, } = {}) {\n    const pseudoMinuses = DEFAULT_PSEUDO_MINUSES.filter((char) => char !== thousandSeparator && char !== decimalSeparator && char !== minusSign);\n    const validatedDecimalPseudoSeparators = validateDecimalPseudoSeparators({\n        decimalSeparator,\n        thousandSeparator,\n        decimalPseudoSeparators,\n    });\n    const prefix = unsafePrefix.endsWith(decimalSeparator) && maximumFractionDigits > 0\n        ? `${unsafePrefix}${CHAR_ZERO_WIDTH_SPACE}`\n        : unsafePrefix;\n    const initializationOnlyPreprocessor = createInitializationOnlyPreprocessor({\n        decimalSeparator,\n        decimalPseudoSeparators: validatedDecimalPseudoSeparators,\n        pseudoMinuses,\n        prefix,\n        postfix,\n        minusSign,\n    });\n    decimalSeparator =\n        maximumFractionDigits <= 0 && decimalSeparator === thousandSeparator\n            ? ''\n            : decimalSeparator;\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: generateMaskExpression({\n            decimalSeparator,\n            maximumFractionDigits,\n            min,\n            minusSign,\n            postfix,\n            prefix,\n            pseudoMinuses,\n            thousandSeparator,\n            decimalPseudoSeparators: validatedDecimalPseudoSeparators,\n        }), preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            initializationOnlyPreprocessor,\n            createAffixesFilterPreprocessor({ prefix, postfix }),\n            createPseudoCharactersPreprocessor({\n                validCharacter: minusSign,\n                pseudoCharacters: pseudoMinuses,\n                prefix,\n                postfix,\n            }),\n            createPseudoCharactersPreprocessor({\n                validCharacter: decimalSeparator,\n                pseudoCharacters: validatedDecimalPseudoSeparators,\n                prefix,\n                postfix,\n            }),\n            createNotEmptyIntegerPartPreprocessor({\n                decimalSeparator,\n                maximumFractionDigits,\n                prefix,\n                postfix,\n            }),\n            createNonRemovableCharsDeletionPreprocessor({\n                decimalSeparator,\n                minimumFractionDigits,\n                thousandSeparator,\n            }),\n            createZeroPrecisionPreprocessor({\n                maximumFractionDigits,\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n            createRepeatedDecimalSeparatorPreprocessor({\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n        ], postprocessors: [\n            createMinMaxPostprocessor({ decimalSeparator, min, max, minusSign }),\n            maskitoPrefixPostprocessorGenerator(prefix),\n            maskitoPostfixPostprocessorGenerator(postfix),\n            createThousandSeparatorPostprocessor({\n                decimalSeparator,\n                thousandSeparator,\n                prefix,\n                postfix,\n                minusSign,\n            }),\n            createDecimalZeroPaddingPostprocessor({\n                decimalSeparator,\n                prefix,\n                postfix,\n                minusSign,\n                minimumFractionDigits: Math.min(minimumFractionDigits, maximumFractionDigits),\n            }),\n            emptyPostprocessor({\n                prefix,\n                postfix,\n                decimalSeparator,\n                minusSign,\n            }),\n        ], plugins: [\n            createLeadingZeroesValidationPlugin({\n                decimalSeparator,\n                thousandSeparator,\n                prefix,\n                postfix,\n            }),\n            createNotEmptyIntegerPlugin({\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n            createMinMaxPlugin({ min, max, decimalSeparator, minusSign }),\n        ], overwriteMode: minimumFractionDigits > 0\n            ? ({ value, selection: [from] }) => from <= value.indexOf(decimalSeparator) ? 'shift' : 'replace'\n            : 'shift' });\n}\n\nexport { maskitoAddOnFocusPlugin, maskitoCaretGuard, maskitoDateOptionsGenerator, maskitoDateRangeOptionsGenerator, maskitoDateTimeOptionsGenerator, maskitoEventHandler, maskitoNumberOptionsGenerator, maskitoParseDate, maskitoParseDateTime, maskitoParseNumber, maskitoParseTime, maskitoPostfixPostprocessorGenerator, maskitoPrefixPostprocessorGenerator, maskitoRejectEvent, maskitoRemoveOnBlurPlugin, maskitoSelectionChangeHandler, maskitoStringifyDate, maskitoStringifyDateTime, maskitoStringifyNumber, maskitoStringifyTime, maskitoTimeOptionsGenerator, maskitoWithPlaceholder };\n", "// Browser-specific build for cd-form-library\n// This will be compiled to a simple IIFE for direct browser use\n\nimport { Maskito } from '@maskito/core';\nimport { maskitoDateOptionsGenerator, maskitoTimeOptionsGenerator } from '@maskito/kit';\n\nconst VERSION = '0.1.70';\n\ninterface FormatConfig {\n  type: 'date' | 'time';\n  pattern: string;\n  defaultMeridiem?: 'AM' | 'PM';\n}\n\nfunction parseFormat(attr: string): FormatConfig | null {\n  const normalized = attr.toLowerCase().trim().replace(/\\s+/g, ' ');\n  \n  if (normalized === 'date:mmddyyyy') {\n    return { type: 'date', pattern: 'mmddyyyy' };\n  }\n  if (normalized === 'date:ddmmyyyy') {\n    return { type: 'date', pattern: 'ddmmyyyy' };\n  }\n  if (normalized === 'time:hhmm am' || normalized === 'time:hhmm') {\n    return { type: 'time', pattern: 'hhmm', defaultMeridiem: 'AM' };\n  }\n  if (normalized === 'time:hhmm pm') {\n    return { type: 'time', pattern: 'hhmm', defaultMeridiem: 'PM' };\n  }\n  \n  return null;\n}\n\nfunction createMaskitoOptions(config: FormatConfig) {\n  if (config.type === 'date') {\n    const mode = config.pattern === 'mmddyyyy' ? 'mm/dd/yyyy' : 'dd/mm/yyyy';\n    return maskitoDateOptionsGenerator({\n      mode,\n      separator: '/'\n    });\n  } else if (config.type === 'time') {\n    return maskitoTimeOptionsGenerator({\n      mode: 'HH:MM AA'\n    });\n  }\n  return null;\n}\n\nfunction initInputFormatting(form: HTMLFormElement) {\n  const inputs = form.querySelectorAll('input[data-input]');\n  \n  inputs.forEach((el) => {\n    const input = el as HTMLInputElement;\n    const attr = input.getAttribute('data-input');\n    \n    if (!attr) return;\n\n    const config = parseFormat(attr);\n    if (!config) return;\n\n    const maskitoOptions = createMaskitoOptions(config);\n    if (!maskitoOptions) return;\n    \n    // Initialize Maskito on the input\n    const maskito = new Maskito(input, maskitoOptions);\n    \n    // Dispatch bound event\n    input.dispatchEvent(new CustomEvent('cd:inputformat:bound', { bubbles: true }));\n\n    // Track changes for event dispatch\n    let previousValue = input.value;\n    \n    input.addEventListener('input', () => {\n      const newValue = input.value;\n      if (newValue !== previousValue) {\n        input.dispatchEvent(new CustomEvent('cd:inputformat:changed', {\n          bubbles: true,\n          detail: { raw: previousValue, formatted: newValue }\n        }));\n        previousValue = newValue;\n      }\n    });\n\n    input.addEventListener('blur', () => {\n      const isValid = input.value.length === 0 || input.checkValidity();\n      input.setAttribute('aria-invalid', (!isValid).toString());\n\n      if (!isValid) {\n        input.dispatchEvent(new CustomEvent('cd:inputformat:invalid', { bubbles: true }));\n      }\n    });\n\n    // Store maskito instance for cleanup if needed\n    (input as any).__maskito = maskito;\n  });\n}\n\n// Form wrapper visibility implementation\nfunction initFormWrapperVisibility() {\n  const wrappers = document.querySelectorAll('[data-show-when]');\n  \n  // Track all input groups that wrappers are listening to\n  const groupListeners = new Map<string, Set<Element>>();\n  \n  wrappers.forEach((wrapper) => {\n    const condition = wrapper.getAttribute('data-show-when');\n    if (!condition) return;\n    \n    const [group, value] = condition.split('=').map(s => s.trim());\n    if (!group || value === undefined) return;\n    \n    // Track this wrapper as listening to this group\n    if (!groupListeners.has(group)) {\n      groupListeners.set(group, new Set());\n    }\n    groupListeners.get(group)!.add(wrapper);\n    \n    // Set initial visibility\n    updateWrapperVisibility(wrapper, group, value);\n  });\n  \n  // Attach event listeners to input groups\n  groupListeners.forEach((wrappers, group) => {\n    const inputs = document.querySelectorAll(`input[name=\"${group}\"], select[name=\"${group}\"], textarea[name=\"${group}\"]`);\n    \n    inputs.forEach((input) => {\n      input.addEventListener('change', () => {\n        wrappers.forEach((wrapper) => {\n          const condition = wrapper.getAttribute('data-show-when');\n          if (!condition) return;\n          \n          const [, value] = condition.split('=').map(s => s.trim());\n          updateWrapperVisibility(wrapper, group, value);\n        });\n      });\n    });\n  });\n}\n\nfunction updateWrapperVisibility(wrapper: Element, group: string, targetValue: string) {\n  const inputs = document.querySelectorAll(`input[name=\"${group}\"], select[name=\"${group}\"], textarea[name=\"${group}\"]`);\n  let currentValue = '';\n  \n  // Get current value from inputs\n  inputs.forEach((input) => {\n    const el = input as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n    \n    if (el.type === 'radio' || el.type === 'checkbox') {\n      const radioInput = el as HTMLInputElement;\n      if (radioInput.checked) {\n        currentValue = radioInput.value;\n      }\n    } else {\n      currentValue = el.value;\n    }\n  });\n  \n  const shouldShow = currentValue === targetValue;\n  const htmlWrapper = wrapper as HTMLElement;\n  \n  if (shouldShow) {\n    htmlWrapper.style.display = '';\n    htmlWrapper.removeAttribute('aria-hidden');\n    \n    // Make focusable elements accessible again\n    const focusableElements = htmlWrapper.querySelectorAll('input, select, textarea, button, [tabindex]');\n    focusableElements.forEach((el) => {\n      (el as HTMLElement).removeAttribute('tabindex');\n    });\n    \n    // Dispatch shown event\n    wrapper.dispatchEvent(new CustomEvent('form-wrapper-visibility:shown', { bubbles: true }));\n  } else {\n    htmlWrapper.style.display = 'none';\n    htmlWrapper.setAttribute('aria-hidden', 'true');\n    \n    // Remove from tab order\n    const focusableElements = htmlWrapper.querySelectorAll('input, select, textarea, button, [tabindex]:not([tabindex=\"-1\"])');\n    focusableElements.forEach((el) => {\n      (el as HTMLElement).setAttribute('tabindex', '-1');\n    });\n    \n    // Dispatch hidden event\n    wrapper.dispatchEvent(new CustomEvent('form-wrapper-visibility:hidden', { bubbles: true }));\n  }\n}\n\n// Dynamic Rows implementation\ninterface DynamicRowGroup {\n  groupName: string;\n  container: Element;\n  template: Element;\n  namePattern: string;\n  rows: Element[];\n  addButton: Element | null;\n}\n\nconst activeGroups = new Map<string, DynamicRowGroup>();\n\nfunction initDynamicRows() {\n  const repeaterGroups = document.querySelectorAll('[data-cd-repeat-group]');\n  \n  repeaterGroups.forEach((container) => {\n    const groupName = container.getAttribute('data-cd-repeat-group');\n    if (!groupName) return;\n    \n    // Skip if container is hidden (will be reinitialized when shown)\n    if (window.getComputedStyle(container).display === 'none') {\n      return;\n    }\n    \n    initializeDynamicRowGroup(groupName, container);\n  });\n}\n\nfunction initializeDynamicRowGroup(groupName: string, container: Element) {\n  // Find template row and add button\n  const template = container.querySelector('[data-cd-repeat-template]');\n  const addButton = container.querySelector('[data-cd-add-row]');\n  const namePattern = container.getAttribute('data-cd-name-pattern') || `${groupName}[{i}]`;\n  \n  if (!template) return;\n\n  // Hide the template\n  (template as HTMLElement).style.display = 'none';\n  \n  // Get existing rows\n  const existingRows = Array.from(container.querySelectorAll('[data-cd-repeat-row]'));\n  \n  const group: DynamicRowGroup = {\n    groupName,\n    container,\n    template,\n    namePattern,\n    rows: existingRows,\n    addButton\n  };\n  \n  // Store the group\n  activeGroups.set(groupName, group);\n  \n  // Attach add button listener\n  if (addButton) {\n    // Remove any existing listeners\n    addButton.removeEventListener('click', handleAddRow);\n    addButton.addEventListener('click', handleAddRow);\n  }\n\n  // Attach remove button listeners\n  const removeButtons = container.querySelectorAll('[data-cd-remove-row]');\n  removeButtons.forEach((removeButton) => {\n    // Remove any existing listeners\n    removeButton.removeEventListener('click', handleRemoveRow);\n    removeButton.addEventListener('click', handleRemoveRow);\n  });\n  \n  // Reindex existing rows\n  reindexRows(group);\n  \n  // Update summaries\n  updateSummaries(group);\n}\n\nfunction handleAddRow(event: Event) {\n  event.preventDefault();\n  const button = event.target as Element;\n  const container = button.closest('[data-cd-repeat-group]');\n  if (!container) return;\n  \n  const groupName = container.getAttribute('data-cd-repeat-group');\n  if (!groupName) return;\n  \n  const group = activeGroups.get(groupName);\n  if (!group) return;\n  \n  addNewRow(group);\n}\n\nfunction handleRemoveRow(event: Event) {\n  event.preventDefault();\n  const button = event.target as Element;\n  const container = button.closest('[data-cd-repeat-group]');\n  if (!container) return;\n  \n  const groupName = container.getAttribute('data-cd-repeat-group');\n  if (!groupName) return;\n  \n  const group = activeGroups.get(groupName);\n  if (!group) return;\n  \n  // Find which row contains the clicked button\n  const rowInfo = findRowContainingElement(group, button);\n  if (!rowInfo) return;\n  \n  removeRow(group, rowInfo.row);\n}\n\nfunction addNewRow(group: DynamicRowGroup) {\n  console.log(`\u2795 Adding new row to group \"${group.groupName}\" (currently ${group.rows.length} rows)`);\n  \n  // Clone the template\n  const newRow = group.template.cloneNode(true) as Element;\n  \n  // Mark as row instead of template\n  newRow.removeAttribute('data-cd-repeat-template');\n  newRow.setAttribute('data-cd-repeat-row', '');\n  \n  // Insert before the template\n  group.container.insertBefore(newRow, group.template);\n  \n  // Add to rows array\n  group.rows.push(newRow);\n\n  // Attach remove button listeners to the new row\n  const removeButtons = newRow.querySelectorAll('[data-cd-remove-row]');\n  console.log(`\u2795 Attaching ${removeButtons.length} remove button listeners to new row`);\n  removeButtons.forEach((removeButton) => {\n    removeButton.addEventListener('click', handleRemoveRow);\n  });\n  \n  // Reindex all rows\n  reindexRows(group);\n  \n  // Update summaries\n  updateSummaries(group);\n  \n  console.log(`\u2795 Row added successfully, new total: ${group.rows.length} rows`);\n  \n  // Dispatch event\n  newRow.dispatchEvent(new CustomEvent('cd:row:added', {\n    bubbles: true,\n    detail: { groupName: group.groupName, rowIndex: group.rows.length - 1 }\n  }));\n}\n\nfunction reindexRows(group: DynamicRowGroup) {\n  group.rows.forEach((row, index) => {\n    const rowIndex = index + 1; // 1-based indexing\n    \n    // Update input names\n    const inputs = row.querySelectorAll('[data-repeat-name]');\n    inputs.forEach((input) => {\n      const fieldName = input.getAttribute('data-repeat-name');\n      if (fieldName) {\n        const finalName = group.namePattern\n          .replace('{i}', rowIndex.toString())\n          .replace('{field}', fieldName);\n        (input as HTMLInputElement).name = finalName;\n      }\n    });\n    \n    // Update IDs and labels if present\n    const elementsWithIds = row.querySelectorAll('[id]');\n    elementsWithIds.forEach((element) => {\n      const originalId = element.getAttribute('data-original-id');\n      if (originalId) {\n        element.id = `${originalId}-${rowIndex}`;\n      } else if (!element.id.endsWith(`-${rowIndex}`)) {\n        element.setAttribute('data-original-id', element.id);\n        element.id = `${element.id}-${rowIndex}`;\n      }\n    });\n    \n    const labels = row.querySelectorAll('label[for]');\n    labels.forEach((label) => {\n      const originalFor = label.getAttribute('data-original-for');\n      if (originalFor) {\n        (label as HTMLLabelElement).htmlFor = `${originalFor}-${rowIndex}`;\n      } else {\n        const currentFor = (label as HTMLLabelElement).htmlFor;\n        if (!currentFor.endsWith(`-${rowIndex}`)) {\n          label.setAttribute('data-original-for', currentFor);\n          (label as HTMLLabelElement).htmlFor = `${currentFor}-${rowIndex}`;\n        }\n      }\n    });\n  });\n  \n  // Dispatch synthetic input events to trigger summary updates\n  group.rows.forEach((row) => {\n    const inputs = row.querySelectorAll('input, select, textarea');\n    inputs.forEach((input) => {\n      input.dispatchEvent(new Event('input', { bubbles: true }));\n    });\n  });\n}\n\nfunction updateSummaries(group: DynamicRowGroup) {\n  console.log(`\uD83D\uDCCA Updating summaries for group \"${group.groupName}\" (${group.rows.length} rows)`);\n  \n  // Find summary containers for this group\n  const summaryContainers = document.querySelectorAll(`[data-summary-for=\"${group.groupName}\"]`);\n  console.log(`\uD83D\uDCCA Found ${summaryContainers.length} summary container(s) for group \"${group.groupName}\"`);\n  \n  summaryContainers.forEach((summaryContainer, containerIndex) => {\n    const template = summaryContainer.querySelector('[data-summary-template]');\n    if (!template) {\n      console.warn(`\uD83D\uDCCA No template found in summary container ${containerIndex} for group \"${group.groupName}\"`);\n      return;\n    }\n    \n    // Remove existing summary rows\n    const existingSummaryRows = summaryContainer.querySelectorAll('[data-summary-row]');\n    console.log(`\uD83D\uDCCA Removing ${existingSummaryRows.length} existing summary rows from container ${containerIndex}`);\n    existingSummaryRows.forEach(row => row.remove());\n    \n    // Create summary rows for each data row\n    console.log(`\uD83D\uDCCA Creating ${group.rows.length} new summary rows for container ${containerIndex}`);\n    group.rows.forEach((dataRow, index) => {\n      const rowIndex = index + 1;\n      const summaryRow = template.cloneNode(true) as Element;\n      \n      // Mark as summary row instead of template\n      summaryRow.removeAttribute('data-summary-template');\n      summaryRow.setAttribute('data-summary-row', '');\n      \n      // Update data-input-field attributes\n      const fieldElements = summaryRow.querySelectorAll('[data-input-field]');\n      console.log(`\uD83D\uDCCA Processing ${fieldElements.length} field elements in summary row ${rowIndex}`);\n      fieldElements.forEach((element) => {\n        const fieldPattern = element.getAttribute('data-input-field');\n        if (fieldPattern) {\n          const finalFieldName = fieldPattern.replace('{i}', rowIndex.toString());\n          element.setAttribute('data-input-field', finalFieldName);\n          console.log(`\uD83D\uDCCA Updated field: ${fieldPattern} \u2192 ${finalFieldName}`);\n        }\n      });\n      \n      // Insert the summary row\n      summaryContainer.appendChild(summaryRow);\n    });\n  });\n  \n  // Trigger TryFormly refresh if available\n  if (typeof (window as any).TryFormly?.refresh === 'function') {\n    console.log('\uD83D\uDCCA Triggering TryFormly.refresh()');\n    (window as any).TryFormly.refresh();\n  } else {\n    console.log('\uD83D\uDCCA TryFormly.refresh() not available');\n  }\n}\n\n// Utility function to find row containing an element\nfunction findRowContainingElement(group: DynamicRowGroup, element: Element): {row: Element, index: number} | null {\n  for (let i = 0; i < group.rows.length; i++) {\n    const row = group.rows[i];\n    if (row.contains(element)) {\n      return { row, index: i };\n    }\n  }\n  return null;\n}\n\nfunction removeRow(group: DynamicRowGroup, targetRow: Element) {\n  console.log(`\u2796 Removing row from group \"${group.groupName}\" (currently ${group.rows.length} rows)`);\n  \n  // Validate minimum row count - prevent removing last row\n  if (group.rows.length <= 1) {\n    console.warn('Cannot remove last row from group:', group.groupName);\n    return;\n  }\n  \n  // Find the target row index\n  const targetIndex = group.rows.indexOf(targetRow);\n  if (targetIndex === -1) {\n    console.warn('Target row not found in group:', group.groupName);\n    return;\n  }\n  \n  console.log(`\u2796 Removing row at index ${targetIndex}`);\n  \n  // Remove the row from DOM\n  targetRow.remove();\n  \n  // Remove from tracking array\n  group.rows.splice(targetIndex, 1);\n  \n  // Reindex remaining rows\n  reindexRows(group);\n  \n  // Update summaries\n  updateSummaries(group);\n  \n  console.log(`\u2796 Row removed successfully, new total: ${group.rows.length} rows`);\n  \n  // Dispatch event\n  targetRow.dispatchEvent(new CustomEvent('cd:row:removed', {\n    bubbles: true,\n    detail: { groupName: group.groupName, rowIndex: targetIndex, removedRow: targetRow }\n  }));\n}\n\n// Export function for reinitializing when containers become visible\nfunction reinitializeDynamicRowGroup(groupName: string, container: Element) {\n  initializeDynamicRowGroup(groupName, container);\n}\n\n// Listen for visibility events to reinitialize hidden groups\ndocument.addEventListener('form-wrapper-visibility:shown', (event) => {\n  const visibleContainer = event.target as Element;\n  const repeaterGroups = visibleContainer.querySelectorAll('[data-cd-repeat-group]');\n  \n  repeaterGroups.forEach((group) => {\n    const groupName = group.getAttribute('data-cd-repeat-group');\n    if (groupName) {\n      reinitializeDynamicRowGroup(groupName, group);\n    }\n  });\n});\n\nfunction initializeLibrary() {\n  const forms = document.querySelectorAll('form[data-cd-form=\"true\"]');\n  \n  forms.forEach((form) => {\n    const formElement = form as HTMLFormElement;\n    \n    try {\n      // Initialize input formatting for inputs with data-input attribute\n      initInputFormatting(formElement);\n      \n      // Initialize form wrapper visibility for elements with data-show-when\n      initFormWrapperVisibility();\n      \n      // Initialize dynamic rows for repeatable sections\n      initDynamicRows();\n      \n      // Dispatch custom event for form enhancement completion\n      formElement.dispatchEvent(new CustomEvent('cdForm:validated', { bubbles: true }));\n    } catch (error) {\n      console.error('Error enhancing form:', error);\n    }\n  });\n}\n\n// Auto-initialize on DOM ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeLibrary);\n} else {\n  initializeLibrary();\n}\n\n// Global exposure for browser environments\n(window as any).CDFormLibrary = {\n  version: VERSION,\n  initialize: initializeLibrary\n};"],
  "mappings": "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",
  "names": ["newValue", "dates", "wrappers"]
}
